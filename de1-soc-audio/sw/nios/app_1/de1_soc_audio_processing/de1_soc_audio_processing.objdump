
de1_soc_audio_processing.elf:     file format elf32-littlenios2
de1_soc_audio_processing.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x08300220

Program Header:
    LOAD off    0x00001000 vaddr 0x08100000 paddr 0x08100000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x08100020 paddr 0x08100020 align 2**12
         filesz 0x002039cc memsz 0x002039cc flags rwx
    LOAD off    0x002049ec vaddr 0x083039ec paddr 0x0830513c align 2**12
         filesz 0x00001750 memsz 0x00001750 flags rw-
    LOAD off    0x0020688c vaddr 0x0830688c paddr 0x0830688c align 2**12
         filesz 0x00000000 memsz 0x00000130 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  08100000  08100000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000208  08100020  08100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .l_buffer     000ffffc  08100228  08100228  00001228  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .r_buffer     000ffffc  08200224  08200224  00101224  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .text         00003718  08300220  08300220  00201220  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .rodata       000000b4  08303938  08303938  00204938  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .rwdata       00001750  083039ec  0830513c  002049ec  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  7 .bss          00000130  0830688c  0830688c  0020688c  2**2
                  ALLOC, SMALL_DATA
  8 .sdram_controller_0 00000000  083069bc  083069bc  0020613c  2**0
                  CONTENTS
  9 .comment      00000059  00000000  00000000  0020613c  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 000005f8  00000000  00000000  00206198  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   00019e58  00000000  00000000  00206790  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00005767  00000000  00000000  002205e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00005cf4  00000000  00000000  00225d4f  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00000ef0  00000000  00000000  0022ba44  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000026c5  00000000  00000000  0022c934  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    00000dcf  00000000  00000000  0022eff9  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000010  00000000  00000000  0022fdc8  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 000001e8  00000000  00000000  0022fdd8  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000003  00000000  00000000  002321cf  2**0
                  CONTENTS, READONLY
 20 .cpu          0000000c  00000000  00000000  002321d2  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  002321de  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  002321df  2**0
                  CONTENTS, READONLY
 23 .sysid_hash   00000004  00000000  00000000  002321e0  2**0
                  CONTENTS, READONLY
 24 .sysid_base   00000004  00000000  00000000  002321e4  2**0
                  CONTENTS, READONLY
 25 .sysid_time   00000004  00000000  00000000  002321e8  2**0
                  CONTENTS, READONLY
 26 .stderr_dev   0000000b  00000000  00000000  002321ec  2**0
                  CONTENTS, READONLY
 27 .stdin_dev    0000000b  00000000  00000000  002321f7  2**0
                  CONTENTS, READONLY
 28 .stdout_dev   0000000b  00000000  00000000  00232202  2**0
                  CONTENTS, READONLY
 29 .sopc_system_name 0000000a  00000000  00000000  0023220d  2**0
                  CONTENTS, READONLY
 30 .quartus_project_dir 00000062  00000000  00000000  00232217  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
08100000 l    d  .entry	00000000 .entry
08100020 l    d  .exceptions	00000000 .exceptions
08100228 l    d  .l_buffer	00000000 .l_buffer
08200224 l    d  .r_buffer	00000000 .r_buffer
08300220 l    d  .text	00000000 .text
08303938 l    d  .rodata	00000000 .rodata
083039ec l    d  .rwdata	00000000 .rwdata
0830688c l    d  .bss	00000000 .bss
083069bc l    d  .sdram_controller_0	00000000 .sdram_controller_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 C:/Users/Medion/Desktop/4.godina/8.semestar/PNRS/Grupni_zadatak/pnrs-2023/de1-soc-audio/sw/nios/app_1/de1_soc_audio_processing_bsp/obj/HAL/src/crt0.o
08300258 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 de1_soc_audio_processing.c
0830025c l     F .text	0000006c timer_isr
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
083008f8 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
08300a60 l     F .text	00000034 alt_dev_reg
083039ec l     O .rwdata	00001060 jtag_uart_0
08304a4c l     O .rwdata	00000048 mailbox_0
08304a94 l     O .rwdata	00000048 mailbox_1
08304adc l     O .rwdata	00000030 audio_and_video_config_0
08304b0c l     O .rwdata	00000030 audio_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
08300d88 l     F .text	00000210 altera_avalon_jtag_uart_irq
08300f98 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_mailbox_simple.c
083015dc l     F .text	0000008c altera_avalon_mailbox_identify
08301668 l     F .text	00000078 altera_avalon_mailbox_post
083016e0 l     F .text	00000140 altera_avalon_mailbox_simple_tx_isr
08301820 l     F .text	000000b0 altera_avalon_mailbox_simple_rx_isr
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
08301f18 l     F .text	00000080 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_up_avalon_audio.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
083028d8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
08302a10 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
08302a3c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
08302c98 l     F .text	000000d4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
08302de8 l     F .text	0000003c alt_get_errno
08302e24 l     F .text	000000dc alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 impure.c
08304ce4 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
083068b4 g     O .bss	00000004 alt_instruction_exception_handler
08301c8c g     F .text	00000150 altera_avalon_mailbox_send
083009e4 g     F .text	0000007c alt_main
083068bc g     O .bss	00000100 alt_irq
0830688c g     O .bss	00000004 mailbox_0
0830513c g       *ABS*	00000000 __flash_rwdata_start
083022b4 g     F .text	00000060 alt_up_audio_read_fifo_avail
08302314 g     F .text	00000068 alt_up_audio_record_r
08302220 g     F .text	00000094 alt_up_audio_reset_audio_core
0830327c g     F .text	00000024 altera_nios2_gen2_irq_init
08100000 g     F .entry	0000000c __reset
08100020 g       *ABS*	00000000 __flash_exceptions_start
083068b8 g     O .bss	00000004 errno
083021e4 g     F .text	0000003c alt_up_audio_write_interrupt_pending
083068a4 g     O .bss	00000004 alt_argv
0830d108 g       *ABS*	00000000 _gp
08301ddc g     F .text	0000013c altera_avalon_mailbox_retrieve_poll
08304b64 g     O .rwdata	00000180 alt_fd_list
08306890 g     O .bss	00000004 mailbox_1
08302be8 g     F .text	00000090 alt_find_dev
083035b8 g     F .text	00000100 memcpy
08302d6c g     F .text	0000007c alt_io_redirect
08303938 g       *ABS*	00000000 __DTOR_END__
08303460 g     F .text	00000098 alt_exception_cause_generated_bad_addr
083018d0 g     F .text	00000078 altera_avalon_mailbox_simple_init
083026ec g     F .text	00000050 alt_up_audio_read_fifo_head
08301194 g     F .text	00000220 altera_avalon_jtag_uart_read
083006b8 g     F .text	00000064 .hidden __udivsi3
08301c14 g     F .text	00000078 altera_avalon_mailbox_status
08301b0c g     F .text	00000108 altera_avalon_mailbox_close
08306894 g     O .bss	00000004 audio_dev
08300378 g     F .text	0000005c start_stop_timer
08305124 g     O .rwdata	00000004 alt_max_fd
0830273c g     F .text	00000068 alt_up_audio_write_fifo_head
08300778 g     F .text	00000180 alt_irq_register
08000000 g       *ABS*	00000000 __alt_mem_sdram_controller_0
08305134 g     O .rwdata	00000004 _global_impure_ptr
083069bc g       *ABS*	00000000 __bss_end
08303174 g     F .text	00000108 alt_tick
08302014 g     F .text	0000003c alt_up_audio_open_dev
08302444 g     F .text	00000068 alt_up_audio_play_r
083030d0 g     F .text	000000a4 alt_alarm_stop
0830689c g     O .bss	00000004 alt_irq_active
081000fc g     F .exceptions	000000cc alt_irq_handler
08304b3c g     O .rwdata	00000028 alt_dev_null
083029f0 g     F .text	00000020 alt_dcache_flush_all
083002c8 g     F .text	000000b0 vometer
0830513c g       *ABS*	00000000 __ram_rwdata_end
0830511c g     O .rwdata	00000008 alt_dev_list
083039ec g       *ABS*	00000000 __ram_rodata_end
0830071c g     F .text	0000005c .hidden __umodsi3
08306898 g     O .bss	00000002 blink
083069bc g       *ABS*	00000000 end
08300cd4 g     F .text	000000b4 altera_avalon_jtag_uart_init
081001c8 g     F .exceptions	00000060 alt_instruction_exception_entry
08303938 g       *ABS*	00000000 __CTOR_LIST__
0c000000 g       *ABS*	00000000 __alt_stack_pointer
08301f98 g     F .text	0000007c alt_avalon_timer_sc_init
083013b4 g     F .text	00000228 altera_avalon_jtag_uart_write
083037e0 g     F .text	00000120 __call_exitprocs
08300220 g     F .text	0000003c _start
083068ac g     O .bss	00000004 _alt_tick_rate
083025f4 g     F .text	000000f8 alt_up_audio_write_fifo
08100228 g     O .l_buffer	000ffffc l_buffer
083068b0 g     O .bss	00000004 _alt_nticks
08300ad0 g     F .text	000000a0 alt_sys_init
08302514 g     F .text	000000e0 alt_up_audio_read_fifo
08303750 g     F .text	00000090 __register_exitproc
08302150 g     F .text	00000058 alt_up_audio_disable_write_interrupt
08301038 g     F .text	00000068 altera_avalon_jtag_uart_close
083039ec g       *ABS*	00000000 __ram_rwdata_start
08303938 g       *ABS*	00000000 __ram_rodata_start
08300b70 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
083033a8 g     F .text	000000b8 alt_get_fd
083020fc g     F .text	00000054 alt_up_audio_enable_write_interrupt
08303540 g     F .text	00000078 memcmp
08300c30 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
083069bc g       *ABS*	00000000 __alt_stack_base
08300c80 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
083020a4 g     F .text	00000058 alt_up_audio_disable_read_interrupt
083032a0 g     F .text	00000108 alt_find_file
08302a78 g     F .text	000000a8 alt_dev_llist_insert
0830688c g       *ABS*	00000000 __bss_start
083003d4 g     F .text	000001f0 main
083023e4 g     F .text	00000060 alt_up_audio_write_fifo_space
083068a8 g     O .bss	00000004 alt_envp
08300bd0 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
08305128 g     O .rwdata	00000004 alt_errno
083005c4 g     F .text	00000080 .hidden __divsi3
08303938 g       *ABS*	00000000 __CTOR_END__
08303938 g       *ABS*	00000000 __flash_rodata_start
08303938 g       *ABS*	00000000 __DTOR_LIST__
08300a94 g     F .text	0000003c alt_irq_init
08303060 g     F .text	00000070 alt_release_fd
083034f8 g     F .text	00000014 atexit
08305138 g     O .rwdata	00000004 _impure_ptr
083068a0 g     O .bss	00000004 alt_argc
08302b84 g     F .text	00000064 _do_dtors
08100020 g       .exceptions	00000000 alt_irq_entry
08305114 g     O .rwdata	00000008 alt_fs_list
08200224 g     O .r_buffer	000ffffc r_buffer
0830237c g     F .text	00000068 alt_up_audio_record_l
08100020 g       *ABS*	00000000 __ram_exceptions_start
0830513c g       *ABS*	00000000 _edata
083069bc g       *ABS*	00000000 _end
08100228 g       *ABS*	00000000 __ram_exceptions_end
083010a0 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
083024ac g     F .text	00000068 alt_up_audio_play_l
0830510c g     O .rwdata	00000008 alt_mailbox_simple_list
0830350c g     F .text	00000034 exit
08300644 g     F .text	00000074 .hidden __modsi3
0c000000 g       *ABS*	00000000 __alt_data_end
08100020 g     F .exceptions	00000000 alt_exception
08301948 g     F .text	000001c4 altera_avalon_mailbox_open
08303900 g     F .text	00000038 _exit
083027a4 g     F .text	00000134 alt_alarm_start
083036b8 g     F .text	00000098 strlen
08302f00 g     F .text	00000160 open
08302c78 g     F .text	00000020 alt_icache_flush_all
08305108 g     O .rwdata	00000004 alt_priority_mask
0830512c g     O .rwdata	00000008 alt_alarm_list
08302b20 g     F .text	00000064 _do_ctors
08302914 g     F .text	000000dc close
08300960 g     F .text	00000084 alt_load
08302050 g     F .text	00000054 alt_up_audio_enable_read_interrupt
083021a8 g     F .text	0000003c alt_up_audio_read_interrupt_pending



Disassembly of section .entry:

08100000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 8100000:	00420c34 	movhi	at,2096
    ori r1, r1, %lo(_start)
 8100004:	08408814 	ori	at,at,544
    jmp r1
 8100008:	0800683a 	jmp	at
	...

Disassembly of section .exceptions:

08100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 8100020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 8100024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 8100028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 810002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 8100030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 8100034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 8100038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 810003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 8100040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 8100044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 8100048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 810004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 8100050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 8100054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 8100058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 810005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 8100060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 8100064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 8100068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 810006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 8100070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 8100074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 8100078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 810007c:	10000326 	beq	r2,zero,810008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 8100080:	20000226 	beq	r4,zero,810008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 8100084:	81000fc0 	call	81000fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 8100088:	00000706 	br	81000a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
 810008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
 8100090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
 8100094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
 8100098:	81001c80 	call	81001c8 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
 810009c:	1000021e 	bne	r2,zero,81000a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
 81000a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 81000a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 81000a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 81000ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 81000b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 81000b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 81000b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 81000bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 81000c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 81000c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 81000c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 81000cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 81000d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 81000d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 81000d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 81000dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 81000e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 81000e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 81000e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 81000ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 81000f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 81000f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 81000f8:	ef80083a 	eret

081000fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 81000fc:	defff904 	addi	sp,sp,-28
 8100100:	dfc00615 	stw	ra,24(sp)
 8100104:	df000515 	stw	fp,20(sp)
 8100108:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 810010c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 8100110:	0005313a 	rdctl	r2,ipending
 8100114:	e0bffc15 	stw	r2,-16(fp)

  return active;
 8100118:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 810011c:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
 8100120:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 8100124:	00800044 	movi	r2,1
 8100128:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 810012c:	e0ffff17 	ldw	r3,-4(fp)
 8100130:	e0bffe17 	ldw	r2,-8(fp)
 8100134:	1884703a 	and	r2,r3,r2
 8100138:	10001226 	beq	r2,zero,8100184 <alt_irq_handler+0x88>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
 810013c:	e0bffd17 	ldw	r2,-12(fp)
 8100140:	100690fa 	slli	r3,r2,3
 8100144:	00820c34 	movhi	r2,2096
 8100148:	1885883a 	add	r2,r3,r2
 810014c:	10da2f17 	ldw	r3,26812(r2)
 8100150:	e0bffd17 	ldw	r2,-12(fp)
 8100154:	100890fa 	slli	r4,r2,3
 8100158:	00820c34 	movhi	r2,2096
 810015c:	2085883a 	add	r2,r4,r2
 8100160:	109a3017 	ldw	r2,26816(r2)
 8100164:	e17ffd17 	ldw	r5,-12(fp)
 8100168:	1009883a 	mov	r4,r2
 810016c:	183ee83a 	callr	r3
#endif
        break;
 8100170:	0001883a 	nop
  NIOS2_READ_IPENDING (active);
 8100174:	0005313a 	rdctl	r2,ipending
 8100178:	e0bffb15 	stw	r2,-20(fp)
  return active;
 810017c:	e0bffb17 	ldw	r2,-20(fp)
 8100180:	00000706 	br	81001a0 <alt_irq_handler+0xa4>
      }
      mask <<= 1;
 8100184:	e0bffe17 	ldw	r2,-8(fp)
 8100188:	1085883a 	add	r2,r2,r2
 810018c:	e0bffe15 	stw	r2,-8(fp)
      i++;
 8100190:	e0bffd17 	ldw	r2,-12(fp)
 8100194:	10800044 	addi	r2,r2,1
 8100198:	e0bffd15 	stw	r2,-12(fp)
      if (active & mask)
 810019c:	003fe306 	br	810012c <alt_irq_handler+0x30>

    } while (1);

    active = alt_irq_pending ();
 81001a0:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
 81001a4:	e0bfff17 	ldw	r2,-4(fp)
 81001a8:	103fdd1e 	bne	r2,zero,8100120 <alt_irq_handler+0x24>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 81001ac:	0001883a 	nop
}
 81001b0:	0001883a 	nop
 81001b4:	e037883a 	mov	sp,fp
 81001b8:	dfc00117 	ldw	ra,4(sp)
 81001bc:	df000017 	ldw	fp,0(sp)
 81001c0:	dec00204 	addi	sp,sp,8
 81001c4:	f800283a 	ret

081001c8 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
 81001c8:	defffb04 	addi	sp,sp,-20
 81001cc:	dfc00415 	stw	ra,16(sp)
 81001d0:	df000315 	stw	fp,12(sp)
 81001d4:	df000304 	addi	fp,sp,12
 81001d8:	e13ffd15 	stw	r4,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
 81001dc:	00bfffc4 	movi	r2,-1
 81001e0:	e0bfff15 	stw	r2,-4(fp)
  badaddr = 0;
 81001e4:	e03ffe15 	stw	zero,-8(fp)
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
 81001e8:	d0a5eb17 	ldw	r2,-26708(gp)
 81001ec:	10000726 	beq	r2,zero,810020c <alt_instruction_exception_entry+0x44>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
 81001f0:	d0a5eb17 	ldw	r2,-26708(gp)
 81001f4:	e0ffff17 	ldw	r3,-4(fp)
 81001f8:	e1bffe17 	ldw	r6,-8(fp)
 81001fc:	e17ffd17 	ldw	r5,-12(fp)
 8100200:	1809883a 	mov	r4,r3
 8100204:	103ee83a 	callr	r2
 8100208:	00000206 	br	8100214 <alt_instruction_exception_entry+0x4c>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
 810020c:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
 8100210:	0005883a 	mov	r2,zero
}
 8100214:	e037883a 	mov	sp,fp
 8100218:	dfc00117 	ldw	ra,4(sp)
 810021c:	df000017 	ldw	fp,0(sp)
 8100220:	dec00204 	addi	sp,sp,8
 8100224:	f800283a 	ret

Disassembly of section .text:

08300220 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 8300220:	06c30034 	movhi	sp,3072
    ori sp, sp, %lo(__alt_stack_pointer)
 8300224:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 8300228:	06820c34 	movhi	gp,2096
    ori gp, gp, %lo(_gp)
 830022c:	d6b44214 	ori	gp,gp,53512
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 8300230:	00820c34 	movhi	r2,2096
    ori r2, r2, %lo(__bss_start)
 8300234:	109a2314 	ori	r2,r2,26764

    movhi r3, %hi(__bss_end)
 8300238:	00c20c34 	movhi	r3,2096
    ori r3, r3, %lo(__bss_end)
 830023c:	18da6f14 	ori	r3,r3,27068

    beq r2, r3, 1f
 8300240:	10c00326 	beq	r2,r3,8300250 <_start+0x30>

0:
    stw zero, (r2)
 8300244:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 8300248:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 830024c:	10fffd36 	bltu	r2,r3,8300244 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 8300250:	83009600 	call	8300960 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 8300254:	83009e40 	call	83009e4 <alt_main>

08300258 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 8300258:	003fff06 	br	8300258 <alt_after_alt_main>

0830025c <timer_isr>:
 830025c:	defffd04 	addi	sp,sp,-12
 8300260:	df000215 	stw	fp,8(sp)
 8300264:	df000204 	addi	fp,sp,8
 8300268:	e13fff15 	stw	r4,-4(fp)
 830026c:	e17ffe15 	stw	r5,-8(fp)
 8300270:	0005883a 	mov	r2,zero
 8300274:	00800035 	stwio	r2,0(zero)
 8300278:	d0a5e40b 	ldhu	r2,-26736(gp)
 830027c:	10bfffcc 	andi	r2,r2,65535
 8300280:	00801035 	stwio	r2,64(zero)
 8300284:	d0a5e40b 	ldhu	r2,-26736(gp)
 8300288:	10bfffcc 	andi	r2,r2,65535
 830028c:	10c00044 	addi	r3,r2,1
 8300290:	00a00034 	movhi	r2,32768
 8300294:	10800044 	addi	r2,r2,1
 8300298:	1884703a 	and	r2,r3,r2
 830029c:	1000040e 	bge	r2,zero,83002b0 <timer_isr+0x54>
 83002a0:	10bfffc4 	addi	r2,r2,-1
 83002a4:	00ffff84 	movi	r3,-2
 83002a8:	10c4b03a 	or	r2,r2,r3
 83002ac:	10800044 	addi	r2,r2,1
 83002b0:	d0a5e40d 	sth	r2,-26736(gp)
 83002b4:	0001883a 	nop
 83002b8:	e037883a 	mov	sp,fp
 83002bc:	df000017 	ldw	fp,0(sp)
 83002c0:	dec00104 	addi	sp,sp,4
 83002c4:	f800283a 	ret

083002c8 <vometer>:
 83002c8:	defffb04 	addi	sp,sp,-20
 83002cc:	dfc00415 	stw	ra,16(sp)
 83002d0:	df000315 	stw	fp,12(sp)
 83002d4:	df000304 	addi	fp,sp,12
 83002d8:	e13ffd15 	stw	r4,-12(fp)
 83002dc:	e03fff8d 	sth	zero,-2(fp)
 83002e0:	00800044 	movi	r2,1
 83002e4:	e0bfff0d 	sth	r2,-4(fp)
 83002e8:	00800044 	movi	r2,1
 83002ec:	e0bffe15 	stw	r2,-8(fp)
 83002f0:	00001406 	br	8300344 <vometer+0x7c>
 83002f4:	e0fffe17 	ldw	r3,-8(fp)
 83002f8:	1805883a 	mov	r2,r3
 83002fc:	1004943a 	slli	r2,r2,16
 8300300:	10c5c83a 	sub	r2,r2,r3
 8300304:	014002c4 	movi	r5,11
 8300308:	1009883a 	mov	r4,r2
 830030c:	83005c40 	call	83005c4 <__divsi3>
 8300310:	1007883a 	mov	r3,r2
 8300314:	e0bffd17 	ldw	r2,-12(fp)
 8300318:	18800e2e 	bgeu	r3,r2,8300354 <vometer+0x8c>
 830031c:	e0ffff8b 	ldhu	r3,-2(fp)
 8300320:	e0bfff0b 	ldhu	r2,-4(fp)
 8300324:	1885883a 	add	r2,r3,r2
 8300328:	e0bfff8d 	sth	r2,-2(fp)
 830032c:	e0bfff0b 	ldhu	r2,-4(fp)
 8300330:	1085883a 	add	r2,r2,r2
 8300334:	e0bfff0d 	sth	r2,-4(fp)
 8300338:	e0bffe17 	ldw	r2,-8(fp)
 830033c:	10800044 	addi	r2,r2,1
 8300340:	e0bffe15 	stw	r2,-8(fp)
 8300344:	e0bffe17 	ldw	r2,-8(fp)
 8300348:	108002d0 	cmplti	r2,r2,11
 830034c:	103fe91e 	bne	r2,zero,83002f4 <vometer+0x2c>
 8300350:	00000106 	br	8300358 <vometer+0x90>
 8300354:	0001883a 	nop
 8300358:	e0bfff8b 	ldhu	r2,-2(fp)
 830035c:	00801035 	stwio	r2,64(zero)
 8300360:	0001883a 	nop
 8300364:	e037883a 	mov	sp,fp
 8300368:	dfc00117 	ldw	ra,4(sp)
 830036c:	df000017 	ldw	fp,0(sp)
 8300370:	dec00204 	addi	sp,sp,8
 8300374:	f800283a 	ret

08300378 <start_stop_timer>:
 8300378:	defffe04 	addi	sp,sp,-8
 830037c:	df000115 	stw	fp,4(sp)
 8300380:	df000104 	addi	fp,sp,4
 8300384:	e13fff15 	stw	r4,-4(fp)
 8300388:	0005883a 	mov	r2,zero
 830038c:	00801035 	stwio	r2,64(zero)
 8300390:	e0bfff17 	ldw	r2,-4(fp)
 8300394:	10000426 	beq	r2,zero,83003a8 <start_stop_timer+0x30>
 8300398:	e0bfff17 	ldw	r2,-4(fp)
 830039c:	10800060 	cmpeqi	r2,r2,1
 83003a0:	1000041e 	bne	r2,zero,83003b4 <start_stop_timer+0x3c>
 83003a4:	00000606 	br	83003c0 <start_stop_timer+0x48>
 83003a8:	00800204 	movi	r2,8
 83003ac:	00800135 	stwio	r2,4(zero)
 83003b0:	00000306 	br	83003c0 <start_stop_timer+0x48>
 83003b4:	008001c4 	movi	r2,7
 83003b8:	00800135 	stwio	r2,4(zero)
 83003bc:	0001883a 	nop
 83003c0:	0001883a 	nop
 83003c4:	e037883a 	mov	sp,fp
 83003c8:	df000017 	ldw	fp,0(sp)
 83003cc:	dec00104 	addi	sp,sp,4
 83003d0:	f800283a 	ret

083003d4 <main>:
 83003d4:	defff904 	addi	sp,sp,-28
 83003d8:	dfc00615 	stw	ra,24(sp)
 83003dc:	df000515 	stw	fp,20(sp)
 83003e0:	df000504 	addi	fp,sp,20
 83003e4:	00800044 	movi	r2,1
 83003e8:	e0bfff15 	stw	r2,-4(fp)
 83003ec:	00bc2014 	movui	r2,61568
 83003f0:	00800235 	stwio	r2,8(zero)
 83003f4:	0080be84 	movi	r2,762
 83003f8:	00800335 	stwio	r2,12(zero)
 83003fc:	00800204 	movi	r2,8
 8300400:	00800135 	stwio	r2,4(zero)
 8300404:	01820c34 	movhi	r6,2096
 8300408:	31809704 	addi	r6,r6,604
 830040c:	000b883a 	mov	r5,zero
 8300410:	01000044 	movi	r4,1
 8300414:	83007780 	call	8300778 <alt_irq_register>
 8300418:	000d883a 	mov	r6,zero
 830041c:	000b883a 	mov	r5,zero
 8300420:	01020c34 	movhi	r4,2096
 8300424:	210e4e04 	addi	r4,r4,14648
 8300428:	83019480 	call	8301948 <altera_avalon_mailbox_open>
 830042c:	d0a5e115 	stw	r2,-26748(gp)
 8300430:	000d883a 	mov	r6,zero
 8300434:	000b883a 	mov	r5,zero
 8300438:	01020c34 	movhi	r4,2096
 830043c:	210e5204 	addi	r4,r4,14664
 8300440:	83019480 	call	8301948 <altera_avalon_mailbox_open>
 8300444:	d0a5e215 	stw	r2,-26744(gp)
 8300448:	01020c34 	movhi	r4,2096
 830044c:	210e5604 	addi	r4,r4,14680
 8300450:	83020140 	call	8302014 <alt_up_audio_open_dev>
 8300454:	d0a5e315 	stw	r2,-26740(gp)
 8300458:	d0a5e117 	ldw	r2,-26748(gp)
 830045c:	e0fffd04 	addi	r3,fp,-12
 8300460:	01801904 	movi	r6,100
 8300464:	180b883a 	mov	r5,r3
 8300468:	1009883a 	mov	r4,r2
 830046c:	8301ddc0 	call	8301ddc <altera_avalon_mailbox_retrieve_poll>
 8300470:	e0bffe17 	ldw	r2,-8(fp)
 8300474:	10000226 	beq	r2,zero,8300480 <main+0xac>
 8300478:	e0bffe17 	ldw	r2,-8(fp)
 830047c:	e0bfff15 	stw	r2,-4(fp)
 8300480:	e0bfff17 	ldw	r2,-4(fp)
 8300484:	108000e0 	cmpeqi	r2,r2,3
 8300488:	1000471e 	bne	r2,zero,83005a8 <main+0x1d4>
 830048c:	e0bfff17 	ldw	r2,-4(fp)
 8300490:	10800108 	cmpgei	r2,r2,4
 8300494:	103ff01e 	bne	r2,zero,8300458 <main+0x84>
 8300498:	e0bfff17 	ldw	r2,-4(fp)
 830049c:	10800060 	cmpeqi	r2,r2,1
 83004a0:	1000041e 	bne	r2,zero,83004b4 <main+0xe0>
 83004a4:	e0bfff17 	ldw	r2,-4(fp)
 83004a8:	108000a0 	cmpeqi	r2,r2,2
 83004ac:	1000281e 	bne	r2,zero,8300550 <main+0x17c>
 83004b0:	00004306 	br	83005c0 <main+0x1ec>
 83004b4:	0009883a 	mov	r4,zero
 83004b8:	83003780 	call	8300378 <start_stop_timer>
 83004bc:	d0a5e317 	ldw	r2,-26740(gp)
 83004c0:	01400044 	movi	r5,1
 83004c4:	1009883a 	mov	r4,r2
 83004c8:	83022b40 	call	83022b4 <alt_up_audio_read_fifo_avail>
 83004cc:	10003926 	beq	r2,zero,83005b4 <main+0x1e0>
 83004d0:	d0a5e317 	ldw	r2,-26740(gp)
 83004d4:	e0fffb04 	addi	r3,fp,-20
 83004d8:	01c00044 	movi	r7,1
 83004dc:	01800044 	movi	r6,1
 83004e0:	180b883a 	mov	r5,r3
 83004e4:	1009883a 	mov	r4,r2
 83004e8:	83025140 	call	8302514 <alt_up_audio_read_fifo>
 83004ec:	d0a5e317 	ldw	r2,-26740(gp)
 83004f0:	e0fffc04 	addi	r3,fp,-16
 83004f4:	000f883a 	mov	r7,zero
 83004f8:	01800044 	movi	r6,1
 83004fc:	180b883a 	mov	r5,r3
 8300500:	1009883a 	mov	r4,r2
 8300504:	83025140 	call	8302514 <alt_up_audio_read_fifo>
 8300508:	e0bffb17 	ldw	r2,-20(fp)
 830050c:	1009883a 	mov	r4,r2
 8300510:	83002c80 	call	83002c8 <vometer>
 8300514:	d0a5e317 	ldw	r2,-26740(gp)
 8300518:	e0fffb04 	addi	r3,fp,-20
 830051c:	01c00044 	movi	r7,1
 8300520:	01800044 	movi	r6,1
 8300524:	180b883a 	mov	r5,r3
 8300528:	1009883a 	mov	r4,r2
 830052c:	83025f40 	call	83025f4 <alt_up_audio_write_fifo>
 8300530:	d0a5e317 	ldw	r2,-26740(gp)
 8300534:	e0fffc04 	addi	r3,fp,-16
 8300538:	000f883a 	mov	r7,zero
 830053c:	01800044 	movi	r6,1
 8300540:	180b883a 	mov	r5,r3
 8300544:	1009883a 	mov	r4,r2
 8300548:	83025f40 	call	83025f4 <alt_up_audio_write_fifo>
 830054c:	00001906 	br	83005b4 <main+0x1e0>
 8300550:	01000044 	movi	r4,1
 8300554:	83003780 	call	8300378 <start_stop_timer>
 8300558:	d0a5e317 	ldw	r2,-26740(gp)
 830055c:	01400044 	movi	r5,1
 8300560:	1009883a 	mov	r4,r2
 8300564:	83022b40 	call	83022b4 <alt_up_audio_read_fifo_avail>
 8300568:	10001426 	beq	r2,zero,83005bc <main+0x1e8>
 830056c:	d0a5e317 	ldw	r2,-26740(gp)
 8300570:	e0fffb04 	addi	r3,fp,-20
 8300574:	01c00044 	movi	r7,1
 8300578:	01800044 	movi	r6,1
 830057c:	180b883a 	mov	r5,r3
 8300580:	1009883a 	mov	r4,r2
 8300584:	83025140 	call	8302514 <alt_up_audio_read_fifo>
 8300588:	d0a5e317 	ldw	r2,-26740(gp)
 830058c:	e0fffc04 	addi	r3,fp,-16
 8300590:	000f883a 	mov	r7,zero
 8300594:	01800044 	movi	r6,1
 8300598:	180b883a 	mov	r5,r3
 830059c:	1009883a 	mov	r4,r2
 83005a0:	83025140 	call	8302514 <alt_up_audio_read_fifo>
 83005a4:	00000506 	br	83005bc <main+0x1e8>
 83005a8:	0009883a 	mov	r4,zero
 83005ac:	83003780 	call	8300378 <start_stop_timer>
 83005b0:	00000306 	br	83005c0 <main+0x1ec>
 83005b4:	0001883a 	nop
 83005b8:	003fa706 	br	8300458 <main+0x84>
 83005bc:	0001883a 	nop
 83005c0:	003fa506 	br	8300458 <main+0x84>

083005c4 <__divsi3>:
 83005c4:	20001a16 	blt	r4,zero,8300630 <__divsi3+0x6c>
 83005c8:	000f883a 	mov	r7,zero
 83005cc:	2800020e 	bge	r5,zero,83005d8 <__divsi3+0x14>
 83005d0:	014bc83a 	sub	r5,zero,r5
 83005d4:	39c0005c 	xori	r7,r7,1
 83005d8:	200d883a 	mov	r6,r4
 83005dc:	00c00044 	movi	r3,1
 83005e0:	2900092e 	bgeu	r5,r4,8300608 <__divsi3+0x44>
 83005e4:	00800804 	movi	r2,32
 83005e8:	00c00044 	movi	r3,1
 83005ec:	00000106 	br	83005f4 <__divsi3+0x30>
 83005f0:	10001226 	beq	r2,zero,830063c <__divsi3+0x78>
 83005f4:	294b883a 	add	r5,r5,r5
 83005f8:	10bfffc4 	addi	r2,r2,-1
 83005fc:	18c7883a 	add	r3,r3,r3
 8300600:	293ffb36 	bltu	r5,r4,83005f0 <__divsi3+0x2c>
 8300604:	18000d26 	beq	r3,zero,830063c <__divsi3+0x78>
 8300608:	0005883a 	mov	r2,zero
 830060c:	31400236 	bltu	r6,r5,8300618 <__divsi3+0x54>
 8300610:	314dc83a 	sub	r6,r6,r5
 8300614:	10c4b03a 	or	r2,r2,r3
 8300618:	1806d07a 	srli	r3,r3,1
 830061c:	280ad07a 	srli	r5,r5,1
 8300620:	183ffa1e 	bne	r3,zero,830060c <__divsi3+0x48>
 8300624:	38000126 	beq	r7,zero,830062c <__divsi3+0x68>
 8300628:	0085c83a 	sub	r2,zero,r2
 830062c:	f800283a 	ret
 8300630:	0109c83a 	sub	r4,zero,r4
 8300634:	01c00044 	movi	r7,1
 8300638:	003fe406 	br	83005cc <__divsi3+0x8>
 830063c:	0005883a 	mov	r2,zero
 8300640:	003ff806 	br	8300624 <__divsi3+0x60>

08300644 <__modsi3>:
 8300644:	20001916 	blt	r4,zero,83006ac <__modsi3+0x68>
 8300648:	000f883a 	mov	r7,zero
 830064c:	2005883a 	mov	r2,r4
 8300650:	2800010e 	bge	r5,zero,8300658 <__modsi3+0x14>
 8300654:	014bc83a 	sub	r5,zero,r5
 8300658:	00c00044 	movi	r3,1
 830065c:	2900092e 	bgeu	r5,r4,8300684 <__modsi3+0x40>
 8300660:	01800804 	movi	r6,32
 8300664:	00c00044 	movi	r3,1
 8300668:	00000106 	br	8300670 <__modsi3+0x2c>
 830066c:	30000d26 	beq	r6,zero,83006a4 <__modsi3+0x60>
 8300670:	294b883a 	add	r5,r5,r5
 8300674:	31bfffc4 	addi	r6,r6,-1
 8300678:	18c7883a 	add	r3,r3,r3
 830067c:	293ffb36 	bltu	r5,r4,830066c <__modsi3+0x28>
 8300680:	18000826 	beq	r3,zero,83006a4 <__modsi3+0x60>
 8300684:	1806d07a 	srli	r3,r3,1
 8300688:	11400136 	bltu	r2,r5,8300690 <__modsi3+0x4c>
 830068c:	1145c83a 	sub	r2,r2,r5
 8300690:	280ad07a 	srli	r5,r5,1
 8300694:	183ffb1e 	bne	r3,zero,8300684 <__modsi3+0x40>
 8300698:	38000126 	beq	r7,zero,83006a0 <__modsi3+0x5c>
 830069c:	0085c83a 	sub	r2,zero,r2
 83006a0:	f800283a 	ret
 83006a4:	2005883a 	mov	r2,r4
 83006a8:	003ffb06 	br	8300698 <__modsi3+0x54>
 83006ac:	0109c83a 	sub	r4,zero,r4
 83006b0:	01c00044 	movi	r7,1
 83006b4:	003fe506 	br	830064c <__modsi3+0x8>

083006b8 <__udivsi3>:
 83006b8:	200d883a 	mov	r6,r4
 83006bc:	2900152e 	bgeu	r5,r4,8300714 <__udivsi3+0x5c>
 83006c0:	28001416 	blt	r5,zero,8300714 <__udivsi3+0x5c>
 83006c4:	00800804 	movi	r2,32
 83006c8:	00c00044 	movi	r3,1
 83006cc:	00000206 	br	83006d8 <__udivsi3+0x20>
 83006d0:	10000e26 	beq	r2,zero,830070c <__udivsi3+0x54>
 83006d4:	28000516 	blt	r5,zero,83006ec <__udivsi3+0x34>
 83006d8:	294b883a 	add	r5,r5,r5
 83006dc:	10bfffc4 	addi	r2,r2,-1
 83006e0:	18c7883a 	add	r3,r3,r3
 83006e4:	293ffa36 	bltu	r5,r4,83006d0 <__udivsi3+0x18>
 83006e8:	18000826 	beq	r3,zero,830070c <__udivsi3+0x54>
 83006ec:	0005883a 	mov	r2,zero
 83006f0:	31400236 	bltu	r6,r5,83006fc <__udivsi3+0x44>
 83006f4:	314dc83a 	sub	r6,r6,r5
 83006f8:	10c4b03a 	or	r2,r2,r3
 83006fc:	1806d07a 	srli	r3,r3,1
 8300700:	280ad07a 	srli	r5,r5,1
 8300704:	183ffa1e 	bne	r3,zero,83006f0 <__udivsi3+0x38>
 8300708:	f800283a 	ret
 830070c:	0005883a 	mov	r2,zero
 8300710:	f800283a 	ret
 8300714:	00c00044 	movi	r3,1
 8300718:	003ff406 	br	83006ec <__udivsi3+0x34>

0830071c <__umodsi3>:
 830071c:	2005883a 	mov	r2,r4
 8300720:	2900132e 	bgeu	r5,r4,8300770 <__umodsi3+0x54>
 8300724:	28001216 	blt	r5,zero,8300770 <__umodsi3+0x54>
 8300728:	01800804 	movi	r6,32
 830072c:	00c00044 	movi	r3,1
 8300730:	00000206 	br	830073c <__umodsi3+0x20>
 8300734:	30000c26 	beq	r6,zero,8300768 <__umodsi3+0x4c>
 8300738:	28000516 	blt	r5,zero,8300750 <__umodsi3+0x34>
 830073c:	294b883a 	add	r5,r5,r5
 8300740:	31bfffc4 	addi	r6,r6,-1
 8300744:	18c7883a 	add	r3,r3,r3
 8300748:	293ffa36 	bltu	r5,r4,8300734 <__umodsi3+0x18>
 830074c:	18000626 	beq	r3,zero,8300768 <__umodsi3+0x4c>
 8300750:	1806d07a 	srli	r3,r3,1
 8300754:	11400136 	bltu	r2,r5,830075c <__umodsi3+0x40>
 8300758:	1145c83a 	sub	r2,r2,r5
 830075c:	280ad07a 	srli	r5,r5,1
 8300760:	183ffb1e 	bne	r3,zero,8300750 <__umodsi3+0x34>
 8300764:	f800283a 	ret
 8300768:	2005883a 	mov	r2,r4
 830076c:	f800283a 	ret
 8300770:	00c00044 	movi	r3,1
 8300774:	003ff606 	br	8300750 <__umodsi3+0x34>

08300778 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
 8300778:	defff004 	addi	sp,sp,-64
 830077c:	df000f15 	stw	fp,60(sp)
 8300780:	df000f04 	addi	fp,sp,60
 8300784:	e13ff315 	stw	r4,-52(fp)
 8300788:	e17ff215 	stw	r5,-56(fp)
 830078c:	e1bff115 	stw	r6,-60(fp)
  int rc = -EINVAL;  
 8300790:	00bffa84 	movi	r2,-22
 8300794:	e0bfff15 	stw	r2,-4(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 8300798:	e0bff317 	ldw	r2,-52(fp)
 830079c:	10800828 	cmpgeui	r2,r2,32
 83007a0:	1000501e 	bne	r2,zero,83008e4 <alt_irq_register+0x16c>
  NIOS2_READ_STATUS (context);
 83007a4:	0005303a 	rdctl	r2,status
 83007a8:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 83007ac:	e0fffd17 	ldw	r3,-12(fp)
 83007b0:	00bfff84 	movi	r2,-2
 83007b4:	1884703a 	and	r2,r3,r2
 83007b8:	1001703a 	wrctl	status,r2
  return context;
 83007bc:	e0bffd17 	ldw	r2,-12(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
 83007c0:	e0bffe15 	stw	r2,-8(fp)

    alt_irq[id].handler = handler;
 83007c4:	e0bff317 	ldw	r2,-52(fp)
 83007c8:	100890fa 	slli	r4,r2,3
 83007cc:	e0fff117 	ldw	r3,-60(fp)
 83007d0:	00820c34 	movhi	r2,2096
 83007d4:	2085883a 	add	r2,r4,r2
 83007d8:	10da2f15 	stw	r3,26812(r2)
    alt_irq[id].context = context;
 83007dc:	e0bff317 	ldw	r2,-52(fp)
 83007e0:	100890fa 	slli	r4,r2,3
 83007e4:	e0fff217 	ldw	r3,-56(fp)
 83007e8:	00820c34 	movhi	r2,2096
 83007ec:	2085883a 	add	r2,r4,r2
 83007f0:	10da3015 	stw	r3,26816(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
 83007f4:	e0bff117 	ldw	r2,-60(fp)
 83007f8:	10001a26 	beq	r2,zero,8300864 <alt_irq_register+0xec>
 83007fc:	e0bff317 	ldw	r2,-52(fp)
 8300800:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_READ_STATUS (context);
 8300804:	0005303a 	rdctl	r2,status
 8300808:	e0bffb15 	stw	r2,-20(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 830080c:	e0fffb17 	ldw	r3,-20(fp)
 8300810:	00bfff84 	movi	r2,-2
 8300814:	1884703a 	and	r2,r3,r2
 8300818:	1001703a 	wrctl	status,r2
  return context;
 830081c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 8300820:	e0bffa15 	stw	r2,-24(fp)

  alt_irq_active |= (1 << id);
 8300824:	00c00044 	movi	r3,1
 8300828:	e0bffc17 	ldw	r2,-16(fp)
 830082c:	1884983a 	sll	r2,r3,r2
 8300830:	1007883a 	mov	r3,r2
 8300834:	d0a5e517 	ldw	r2,-26732(gp)
 8300838:	1884b03a 	or	r2,r3,r2
 830083c:	d0a5e515 	stw	r2,-26732(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 8300840:	d0a5e517 	ldw	r2,-26732(gp)
 8300844:	100170fa 	wrctl	ienable,r2
 8300848:	e0bffa17 	ldw	r2,-24(fp)
 830084c:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context);
 8300850:	e0bff917 	ldw	r2,-28(fp)
 8300854:	1001703a 	wrctl	status,r2
}
 8300858:	0001883a 	nop

  alt_irq_enable_all(status);

  return 0;
 830085c:	0005883a 	mov	r2,zero
 8300860:	00001a06 	br	83008cc <alt_irq_register+0x154>
 8300864:	e0bff317 	ldw	r2,-52(fp)
 8300868:	e0bff815 	stw	r2,-32(fp)
  NIOS2_READ_STATUS (context);
 830086c:	0005303a 	rdctl	r2,status
 8300870:	e0bff715 	stw	r2,-36(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8300874:	e0fff717 	ldw	r3,-36(fp)
 8300878:	00bfff84 	movi	r2,-2
 830087c:	1884703a 	and	r2,r3,r2
 8300880:	1001703a 	wrctl	status,r2
  return context;
 8300884:	e0bff717 	ldw	r2,-36(fp)
  status = alt_irq_disable_all ();
 8300888:	e0bff615 	stw	r2,-40(fp)
  alt_irq_active &= ~(1 << id);
 830088c:	00c00044 	movi	r3,1
 8300890:	e0bff817 	ldw	r2,-32(fp)
 8300894:	1884983a 	sll	r2,r3,r2
 8300898:	0084303a 	nor	r2,zero,r2
 830089c:	1007883a 	mov	r3,r2
 83008a0:	d0a5e517 	ldw	r2,-26732(gp)
 83008a4:	1884703a 	and	r2,r3,r2
 83008a8:	d0a5e515 	stw	r2,-26732(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 83008ac:	d0a5e517 	ldw	r2,-26732(gp)
 83008b0:	100170fa 	wrctl	ienable,r2
 83008b4:	e0bff617 	ldw	r2,-40(fp)
 83008b8:	e0bff515 	stw	r2,-44(fp)
  NIOS2_WRITE_STATUS (context);
 83008bc:	e0bff517 	ldw	r2,-44(fp)
 83008c0:	1001703a 	wrctl	status,r2
}
 83008c4:	0001883a 	nop
  return 0;
 83008c8:	0005883a 	mov	r2,zero
 83008cc:	e0bfff15 	stw	r2,-4(fp)
 83008d0:	e0bffe17 	ldw	r2,-8(fp)
 83008d4:	e0bff415 	stw	r2,-48(fp)
  NIOS2_WRITE_STATUS (context);
 83008d8:	e0bff417 	ldw	r2,-48(fp)
 83008dc:	1001703a 	wrctl	status,r2
}
 83008e0:	0001883a 	nop

    alt_irq_enable_all(status);
  }
  return rc; 
 83008e4:	e0bfff17 	ldw	r2,-4(fp)
}
 83008e8:	e037883a 	mov	sp,fp
 83008ec:	df000017 	ldw	fp,0(sp)
 83008f0:	dec00104 	addi	sp,sp,4
 83008f4:	f800283a 	ret

083008f8 <alt_load_section>:
 83008f8:	defffc04 	addi	sp,sp,-16
 83008fc:	df000315 	stw	fp,12(sp)
 8300900:	df000304 	addi	fp,sp,12
 8300904:	e13fff15 	stw	r4,-4(fp)
 8300908:	e17ffe15 	stw	r5,-8(fp)
 830090c:	e1bffd15 	stw	r6,-12(fp)
 8300910:	e0fffe17 	ldw	r3,-8(fp)
 8300914:	e0bfff17 	ldw	r2,-4(fp)
 8300918:	18800c26 	beq	r3,r2,830094c <alt_load_section+0x54>
 830091c:	00000806 	br	8300940 <alt_load_section+0x48>
 8300920:	e0ffff17 	ldw	r3,-4(fp)
 8300924:	18800104 	addi	r2,r3,4
 8300928:	e0bfff15 	stw	r2,-4(fp)
 830092c:	e0bffe17 	ldw	r2,-8(fp)
 8300930:	11000104 	addi	r4,r2,4
 8300934:	e13ffe15 	stw	r4,-8(fp)
 8300938:	18c00017 	ldw	r3,0(r3)
 830093c:	10c00015 	stw	r3,0(r2)
 8300940:	e0fffe17 	ldw	r3,-8(fp)
 8300944:	e0bffd17 	ldw	r2,-12(fp)
 8300948:	18bff51e 	bne	r3,r2,8300920 <alt_load_section+0x28>
 830094c:	0001883a 	nop
 8300950:	e037883a 	mov	sp,fp
 8300954:	df000017 	ldw	fp,0(sp)
 8300958:	dec00104 	addi	sp,sp,4
 830095c:	f800283a 	ret

08300960 <alt_load>:
 8300960:	defffe04 	addi	sp,sp,-8
 8300964:	dfc00115 	stw	ra,4(sp)
 8300968:	df000015 	stw	fp,0(sp)
 830096c:	d839883a 	mov	fp,sp
 8300970:	01820c34 	movhi	r6,2096
 8300974:	31944f04 	addi	r6,r6,20796
 8300978:	01420c34 	movhi	r5,2096
 830097c:	294e7b04 	addi	r5,r5,14828
 8300980:	01020c34 	movhi	r4,2096
 8300984:	21144f04 	addi	r4,r4,20796
 8300988:	83008f80 	call	83008f8 <alt_load_section>
 830098c:	01820434 	movhi	r6,2064
 8300990:	31808a04 	addi	r6,r6,552
 8300994:	01420434 	movhi	r5,2064
 8300998:	29400804 	addi	r5,r5,32
 830099c:	01020434 	movhi	r4,2064
 83009a0:	21000804 	addi	r4,r4,32
 83009a4:	83008f80 	call	83008f8 <alt_load_section>
 83009a8:	01820c34 	movhi	r6,2096
 83009ac:	318e7b04 	addi	r6,r6,14828
 83009b0:	01420c34 	movhi	r5,2096
 83009b4:	294e4e04 	addi	r5,r5,14648
 83009b8:	01020c34 	movhi	r4,2096
 83009bc:	210e4e04 	addi	r4,r4,14648
 83009c0:	83008f80 	call	83008f8 <alt_load_section>
 83009c4:	83029f00 	call	83029f0 <alt_dcache_flush_all>
 83009c8:	8302c780 	call	8302c78 <alt_icache_flush_all>
 83009cc:	0001883a 	nop
 83009d0:	e037883a 	mov	sp,fp
 83009d4:	dfc00117 	ldw	ra,4(sp)
 83009d8:	df000017 	ldw	fp,0(sp)
 83009dc:	dec00204 	addi	sp,sp,8
 83009e0:	f800283a 	ret

083009e4 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 83009e4:	defffd04 	addi	sp,sp,-12
 83009e8:	dfc00215 	stw	ra,8(sp)
 83009ec:	df000115 	stw	fp,4(sp)
 83009f0:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 83009f4:	0009883a 	mov	r4,zero
 83009f8:	8300a940 	call	8300a94 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 83009fc:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 8300a00:	8300ad00 	call	8300ad0 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 8300a04:	01820c34 	movhi	r6,2096
 8300a08:	318e5a04 	addi	r6,r6,14696
 8300a0c:	01420c34 	movhi	r5,2096
 8300a10:	294e5a04 	addi	r5,r5,14696
 8300a14:	01020c34 	movhi	r4,2096
 8300a18:	210e5a04 	addi	r4,r4,14696
 8300a1c:	8302d6c0 	call	8302d6c <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 8300a20:	8302b200 	call	8302b20 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 8300a24:	01020c34 	movhi	r4,2096
 8300a28:	210ae104 	addi	r4,r4,11140
 8300a2c:	83034f80 	call	83034f8 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 8300a30:	d0a5e617 	ldw	r2,-26728(gp)
 8300a34:	d0e5e717 	ldw	r3,-26724(gp)
 8300a38:	d125e817 	ldw	r4,-26720(gp)
 8300a3c:	200d883a 	mov	r6,r4
 8300a40:	180b883a 	mov	r5,r3
 8300a44:	1009883a 	mov	r4,r2
 8300a48:	83003d40 	call	83003d4 <main>
 8300a4c:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 8300a50:	01000044 	movi	r4,1
 8300a54:	83029140 	call	8302914 <close>
  exit (result);
 8300a58:	e13fff17 	ldw	r4,-4(fp)
 8300a5c:	830350c0 	call	830350c <exit>

08300a60 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 8300a60:	defffd04 	addi	sp,sp,-12
 8300a64:	dfc00215 	stw	ra,8(sp)
 8300a68:	df000115 	stw	fp,4(sp)
 8300a6c:	df000104 	addi	fp,sp,4
 8300a70:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 8300a74:	d1600504 	addi	r5,gp,-32748
 8300a78:	e13fff17 	ldw	r4,-4(fp)
 8300a7c:	8302a780 	call	8302a78 <alt_dev_llist_insert>
}
 8300a80:	e037883a 	mov	sp,fp
 8300a84:	dfc00117 	ldw	ra,4(sp)
 8300a88:	df000017 	ldw	fp,0(sp)
 8300a8c:	dec00204 	addi	sp,sp,8
 8300a90:	f800283a 	ret

08300a94 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 8300a94:	defffd04 	addi	sp,sp,-12
 8300a98:	dfc00215 	stw	ra,8(sp)
 8300a9c:	df000115 	stw	fp,4(sp)
 8300aa0:	df000104 	addi	fp,sp,4
 8300aa4:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_1, nios2_gen2_1);
 8300aa8:	830327c0 	call	830327c <altera_nios2_gen2_irq_init>
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 8300aac:	00800044 	movi	r2,1
 8300ab0:	1001703a 	wrctl	status,r2
}
 8300ab4:	0001883a 	nop
    alt_irq_cpu_enable_interrupts();
}
 8300ab8:	0001883a 	nop
 8300abc:	e037883a 	mov	sp,fp
 8300ac0:	dfc00117 	ldw	ra,4(sp)
 8300ac4:	df000017 	ldw	fp,0(sp)
 8300ac8:	dec00204 	addi	sp,sp,8
 8300acc:	f800283a 	ret

08300ad0 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 8300ad0:	defffe04 	addi	sp,sp,-8
 8300ad4:	dfc00115 	stw	ra,4(sp)
 8300ad8:	df000015 	stw	fp,0(sp)
 8300adc:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1, timer_1);
 8300ae0:	01c0fa04 	movi	r7,1000
 8300ae4:	01800044 	movi	r6,1
 8300ae8:	000b883a 	mov	r5,zero
 8300aec:	0009883a 	mov	r4,zero
 8300af0:	8301f980 	call	8301f98 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 8300af4:	01800084 	movi	r6,2
 8300af8:	000b883a 	mov	r5,zero
 8300afc:	01020c34 	movhi	r4,2096
 8300b00:	210e8504 	addi	r4,r4,14868
 8300b04:	8300cd40 	call	8300cd4 <altera_avalon_jtag_uart_init>
 8300b08:	01020c34 	movhi	r4,2096
 8300b0c:	210e7b04 	addi	r4,r4,14828
 8300b10:	8300a600 	call	8300a60 <alt_dev_reg>
    ALTERA_AVALON_MAILBOX_SIMPLE_INIT ( MAILBOX_0, mailbox_0);
 8300b14:	01bfffc4 	movi	r6,-1
 8300b18:	000b883a 	mov	r5,zero
 8300b1c:	01020c34 	movhi	r4,2096
 8300b20:	21129304 	addi	r4,r4,19020
 8300b24:	83018d00 	call	83018d0 <altera_avalon_mailbox_simple_init>
    ALTERA_AVALON_MAILBOX_SIMPLE_INIT ( MAILBOX_1, mailbox_1);
 8300b28:	01bfffc4 	movi	r6,-1
 8300b2c:	000b883a 	mov	r5,zero
 8300b30:	01020c34 	movhi	r4,2096
 8300b34:	2112a504 	addi	r4,r4,19092
 8300b38:	83018d00 	call	83018d0 <altera_avalon_mailbox_simple_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
 8300b3c:	0001883a 	nop
    ALTERA_UP_AVALON_AUDIO_AND_VIDEO_CONFIG_INIT ( AUDIO_AND_VIDEO_CONFIG_0, audio_and_video_config_0);
 8300b40:	01020c34 	movhi	r4,2096
 8300b44:	2112b704 	addi	r4,r4,19164
 8300b48:	8300a600 	call	8300a60 <alt_dev_reg>
    ALTERA_UP_AVALON_AUDIO_INIT ( AUDIO_0, audio_0);
 8300b4c:	01020c34 	movhi	r4,2096
 8300b50:	2112c304 	addi	r4,r4,19212
 8300b54:	8300a600 	call	8300a60 <alt_dev_reg>
}
 8300b58:	0001883a 	nop
 8300b5c:	e037883a 	mov	sp,fp
 8300b60:	dfc00117 	ldw	ra,4(sp)
 8300b64:	df000017 	ldw	fp,0(sp)
 8300b68:	dec00204 	addi	sp,sp,8
 8300b6c:	f800283a 	ret

08300b70 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 8300b70:	defffa04 	addi	sp,sp,-24
 8300b74:	dfc00515 	stw	ra,20(sp)
 8300b78:	df000415 	stw	fp,16(sp)
 8300b7c:	df000404 	addi	fp,sp,16
 8300b80:	e13ffe15 	stw	r4,-8(fp)
 8300b84:	e17ffd15 	stw	r5,-12(fp)
 8300b88:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 8300b8c:	e0bffe17 	ldw	r2,-8(fp)
 8300b90:	10800017 	ldw	r2,0(r2)
 8300b94:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 8300b98:	e0bfff17 	ldw	r2,-4(fp)
 8300b9c:	10c00a04 	addi	r3,r2,40
 8300ba0:	e0bffe17 	ldw	r2,-8(fp)
 8300ba4:	10800217 	ldw	r2,8(r2)
 8300ba8:	100f883a 	mov	r7,r2
 8300bac:	e1bffc17 	ldw	r6,-16(fp)
 8300bb0:	e17ffd17 	ldw	r5,-12(fp)
 8300bb4:	1809883a 	mov	r4,r3
 8300bb8:	83011940 	call	8301194 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 8300bbc:	e037883a 	mov	sp,fp
 8300bc0:	dfc00117 	ldw	ra,4(sp)
 8300bc4:	df000017 	ldw	fp,0(sp)
 8300bc8:	dec00204 	addi	sp,sp,8
 8300bcc:	f800283a 	ret

08300bd0 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 8300bd0:	defffa04 	addi	sp,sp,-24
 8300bd4:	dfc00515 	stw	ra,20(sp)
 8300bd8:	df000415 	stw	fp,16(sp)
 8300bdc:	df000404 	addi	fp,sp,16
 8300be0:	e13ffe15 	stw	r4,-8(fp)
 8300be4:	e17ffd15 	stw	r5,-12(fp)
 8300be8:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 8300bec:	e0bffe17 	ldw	r2,-8(fp)
 8300bf0:	10800017 	ldw	r2,0(r2)
 8300bf4:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 8300bf8:	e0bfff17 	ldw	r2,-4(fp)
 8300bfc:	10c00a04 	addi	r3,r2,40
 8300c00:	e0bffe17 	ldw	r2,-8(fp)
 8300c04:	10800217 	ldw	r2,8(r2)
 8300c08:	100f883a 	mov	r7,r2
 8300c0c:	e1bffc17 	ldw	r6,-16(fp)
 8300c10:	e17ffd17 	ldw	r5,-12(fp)
 8300c14:	1809883a 	mov	r4,r3
 8300c18:	83013b40 	call	83013b4 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 8300c1c:	e037883a 	mov	sp,fp
 8300c20:	dfc00117 	ldw	ra,4(sp)
 8300c24:	df000017 	ldw	fp,0(sp)
 8300c28:	dec00204 	addi	sp,sp,8
 8300c2c:	f800283a 	ret

08300c30 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 8300c30:	defffc04 	addi	sp,sp,-16
 8300c34:	dfc00315 	stw	ra,12(sp)
 8300c38:	df000215 	stw	fp,8(sp)
 8300c3c:	df000204 	addi	fp,sp,8
 8300c40:	e13ffe15 	stw	r4,-8(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 8300c44:	e0bffe17 	ldw	r2,-8(fp)
 8300c48:	10800017 	ldw	r2,0(r2)
 8300c4c:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 8300c50:	e0bfff17 	ldw	r2,-4(fp)
 8300c54:	10c00a04 	addi	r3,r2,40
 8300c58:	e0bffe17 	ldw	r2,-8(fp)
 8300c5c:	10800217 	ldw	r2,8(r2)
 8300c60:	100b883a 	mov	r5,r2
 8300c64:	1809883a 	mov	r4,r3
 8300c68:	83010380 	call	8301038 <altera_avalon_jtag_uart_close>
}
 8300c6c:	e037883a 	mov	sp,fp
 8300c70:	dfc00117 	ldw	ra,4(sp)
 8300c74:	df000017 	ldw	fp,0(sp)
 8300c78:	dec00204 	addi	sp,sp,8
 8300c7c:	f800283a 	ret

08300c80 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 8300c80:	defffa04 	addi	sp,sp,-24
 8300c84:	dfc00515 	stw	ra,20(sp)
 8300c88:	df000415 	stw	fp,16(sp)
 8300c8c:	df000404 	addi	fp,sp,16
 8300c90:	e13ffe15 	stw	r4,-8(fp)
 8300c94:	e17ffd15 	stw	r5,-12(fp)
 8300c98:	e1bffc15 	stw	r6,-16(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 8300c9c:	e0bffe17 	ldw	r2,-8(fp)
 8300ca0:	10800017 	ldw	r2,0(r2)
 8300ca4:	e0bfff15 	stw	r2,-4(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 8300ca8:	e0bfff17 	ldw	r2,-4(fp)
 8300cac:	10800a04 	addi	r2,r2,40
 8300cb0:	e1bffc17 	ldw	r6,-16(fp)
 8300cb4:	e17ffd17 	ldw	r5,-12(fp)
 8300cb8:	1009883a 	mov	r4,r2
 8300cbc:	83010a00 	call	83010a0 <altera_avalon_jtag_uart_ioctl>
}
 8300cc0:	e037883a 	mov	sp,fp
 8300cc4:	dfc00117 	ldw	ra,4(sp)
 8300cc8:	df000017 	ldw	fp,0(sp)
 8300ccc:	dec00204 	addi	sp,sp,8
 8300cd0:	f800283a 	ret

08300cd4 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 8300cd4:	defffb04 	addi	sp,sp,-20
 8300cd8:	dfc00415 	stw	ra,16(sp)
 8300cdc:	df000315 	stw	fp,12(sp)
 8300ce0:	df000304 	addi	fp,sp,12
 8300ce4:	e13fff15 	stw	r4,-4(fp)
 8300ce8:	e17ffe15 	stw	r5,-8(fp)
 8300cec:	e1bffd15 	stw	r6,-12(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 8300cf0:	e0bfff17 	ldw	r2,-4(fp)
 8300cf4:	00c00044 	movi	r3,1
 8300cf8:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 8300cfc:	e0bfff17 	ldw	r2,-4(fp)
 8300d00:	10800017 	ldw	r2,0(r2)
 8300d04:	10800104 	addi	r2,r2,4
 8300d08:	1007883a 	mov	r3,r2
 8300d0c:	e0bfff17 	ldw	r2,-4(fp)
 8300d10:	10800817 	ldw	r2,32(r2)
 8300d14:	18800035 	stwio	r2,0(r3)
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
                      sp, NULL);
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
 8300d18:	e0bffd17 	ldw	r2,-12(fp)
 8300d1c:	01820c34 	movhi	r6,2096
 8300d20:	31836204 	addi	r6,r6,3464
 8300d24:	e17fff17 	ldw	r5,-4(fp)
 8300d28:	1009883a 	mov	r4,r2
 8300d2c:	83007780 	call	8300778 <alt_irq_register>
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 8300d30:	e0bfff17 	ldw	r2,-4(fp)
 8300d34:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 8300d38:	e0bfff17 	ldw	r2,-4(fp)
 8300d3c:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 8300d40:	d0e5e917 	ldw	r3,-26716(gp)
 8300d44:	e1ffff17 	ldw	r7,-4(fp)
 8300d48:	01820c34 	movhi	r6,2096
 8300d4c:	3183e604 	addi	r6,r6,3992
 8300d50:	180b883a 	mov	r5,r3
 8300d54:	1009883a 	mov	r4,r2
 8300d58:	83027a40 	call	83027a4 <alt_alarm_start>
 8300d5c:	1000040e 	bge	r2,zero,8300d70 <altera_avalon_jtag_uart_init+0x9c>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 8300d60:	e0ffff17 	ldw	r3,-4(fp)
 8300d64:	00a00034 	movhi	r2,32768
 8300d68:	10bfffc4 	addi	r2,r2,-1
 8300d6c:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 8300d70:	0001883a 	nop
 8300d74:	e037883a 	mov	sp,fp
 8300d78:	dfc00117 	ldw	ra,4(sp)
 8300d7c:	df000017 	ldw	fp,0(sp)
 8300d80:	dec00204 	addi	sp,sp,8
 8300d84:	f800283a 	ret

08300d88 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 8300d88:	defff704 	addi	sp,sp,-36
 8300d8c:	df000815 	stw	fp,32(sp)
 8300d90:	df000804 	addi	fp,sp,32
 8300d94:	e13ff915 	stw	r4,-28(fp)
 8300d98:	e17ff815 	stw	r5,-32(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 8300d9c:	e0bff917 	ldw	r2,-28(fp)
 8300da0:	e0bffd15 	stw	r2,-12(fp)
  unsigned int base = sp->base;
 8300da4:	e0bffd17 	ldw	r2,-12(fp)
 8300da8:	10800017 	ldw	r2,0(r2)
 8300dac:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 8300db0:	e0bffc17 	ldw	r2,-16(fp)
 8300db4:	10800104 	addi	r2,r2,4
 8300db8:	10800037 	ldwio	r2,0(r2)
 8300dbc:	e0bffb15 	stw	r2,-20(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 8300dc0:	e0bffb17 	ldw	r2,-20(fp)
 8300dc4:	1080c00c 	andi	r2,r2,768
 8300dc8:	10006d26 	beq	r2,zero,8300f80 <altera_avalon_jtag_uart_irq+0x1f8>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 8300dcc:	e0bffb17 	ldw	r2,-20(fp)
 8300dd0:	1080400c 	andi	r2,r2,256
 8300dd4:	10003526 	beq	r2,zero,8300eac <altera_avalon_jtag_uart_irq+0x124>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 8300dd8:	00800074 	movhi	r2,1
 8300ddc:	e0bfff15 	stw	r2,-4(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 8300de0:	e0bffd17 	ldw	r2,-12(fp)
 8300de4:	10800a17 	ldw	r2,40(r2)
 8300de8:	10800044 	addi	r2,r2,1
 8300dec:	1081ffcc 	andi	r2,r2,2047
 8300df0:	e0bffa15 	stw	r2,-24(fp)
        if (next == sp->rx_out)
 8300df4:	e0bffd17 	ldw	r2,-12(fp)
 8300df8:	10800b17 	ldw	r2,44(r2)
 8300dfc:	e0fffa17 	ldw	r3,-24(fp)
 8300e00:	18801526 	beq	r3,r2,8300e58 <altera_avalon_jtag_uart_irq+0xd0>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 8300e04:	e0bffc17 	ldw	r2,-16(fp)
 8300e08:	10800037 	ldwio	r2,0(r2)
 8300e0c:	e0bfff15 	stw	r2,-4(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 8300e10:	e0bfff17 	ldw	r2,-4(fp)
 8300e14:	10a0000c 	andi	r2,r2,32768
 8300e18:	10001126 	beq	r2,zero,8300e60 <altera_avalon_jtag_uart_irq+0xd8>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 8300e1c:	e0bffd17 	ldw	r2,-12(fp)
 8300e20:	10800a17 	ldw	r2,40(r2)
 8300e24:	e0ffff17 	ldw	r3,-4(fp)
 8300e28:	1809883a 	mov	r4,r3
 8300e2c:	e0fffd17 	ldw	r3,-12(fp)
 8300e30:	1885883a 	add	r2,r3,r2
 8300e34:	11000e05 	stb	r4,56(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 8300e38:	e0bffd17 	ldw	r2,-12(fp)
 8300e3c:	10800a17 	ldw	r2,40(r2)
 8300e40:	10800044 	addi	r2,r2,1
 8300e44:	10c1ffcc 	andi	r3,r2,2047
 8300e48:	e0bffd17 	ldw	r2,-12(fp)
 8300e4c:	10c00a15 	stw	r3,40(r2)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
 8300e50:	0001883a 	nop
      {
 8300e54:	003fe206 	br	8300de0 <altera_avalon_jtag_uart_irq+0x58>
          break;
 8300e58:	0001883a 	nop
 8300e5c:	00000106 	br	8300e64 <altera_avalon_jtag_uart_irq+0xdc>
          break;
 8300e60:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 8300e64:	e0bfff17 	ldw	r2,-4(fp)
 8300e68:	10bfffec 	andhi	r2,r2,65535
 8300e6c:	10000f26 	beq	r2,zero,8300eac <altera_avalon_jtag_uart_irq+0x124>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 8300e70:	e0bffd17 	ldw	r2,-12(fp)
 8300e74:	10c00817 	ldw	r3,32(r2)
 8300e78:	00bfff84 	movi	r2,-2
 8300e7c:	1886703a 	and	r3,r3,r2
 8300e80:	e0bffd17 	ldw	r2,-12(fp)
 8300e84:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 8300e88:	e0bffc17 	ldw	r2,-16(fp)
 8300e8c:	10800104 	addi	r2,r2,4
 8300e90:	1007883a 	mov	r3,r2
 8300e94:	e0bffd17 	ldw	r2,-12(fp)
 8300e98:	10800817 	ldw	r2,32(r2)
 8300e9c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 8300ea0:	e0bffc17 	ldw	r2,-16(fp)
 8300ea4:	10800104 	addi	r2,r2,4
 8300ea8:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 8300eac:	e0bffb17 	ldw	r2,-20(fp)
 8300eb0:	1080800c 	andi	r2,r2,512
 8300eb4:	103fbe26 	beq	r2,zero,8300db0 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 8300eb8:	e0bffb17 	ldw	r2,-20(fp)
 8300ebc:	1004d43a 	srli	r2,r2,16
 8300ec0:	e0bffe15 	stw	r2,-8(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 8300ec4:	00001406 	br	8300f18 <altera_avalon_jtag_uart_irq+0x190>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 8300ec8:	e0bffc17 	ldw	r2,-16(fp)
 8300ecc:	e0fffd17 	ldw	r3,-12(fp)
 8300ed0:	18c00d17 	ldw	r3,52(r3)
 8300ed4:	e13ffd17 	ldw	r4,-12(fp)
 8300ed8:	20c7883a 	add	r3,r4,r3
 8300edc:	18c20e03 	ldbu	r3,2104(r3)
 8300ee0:	18c03fcc 	andi	r3,r3,255
 8300ee4:	18c0201c 	xori	r3,r3,128
 8300ee8:	18ffe004 	addi	r3,r3,-128
 8300eec:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 8300ef0:	e0bffd17 	ldw	r2,-12(fp)
 8300ef4:	10800d17 	ldw	r2,52(r2)
 8300ef8:	10800044 	addi	r2,r2,1
 8300efc:	10c1ffcc 	andi	r3,r2,2047
 8300f00:	e0bffd17 	ldw	r2,-12(fp)
 8300f04:	10c00d15 	stw	r3,52(r2)
 8300f08:	0001883a 	nop

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 8300f0c:	e0bffe17 	ldw	r2,-8(fp)
 8300f10:	10bfffc4 	addi	r2,r2,-1
 8300f14:	e0bffe15 	stw	r2,-8(fp)
      while (space > 0 && sp->tx_out != sp->tx_in)
 8300f18:	e0bffe17 	ldw	r2,-8(fp)
 8300f1c:	10000526 	beq	r2,zero,8300f34 <altera_avalon_jtag_uart_irq+0x1ac>
 8300f20:	e0bffd17 	ldw	r2,-12(fp)
 8300f24:	10c00d17 	ldw	r3,52(r2)
 8300f28:	e0bffd17 	ldw	r2,-12(fp)
 8300f2c:	10800c17 	ldw	r2,48(r2)
 8300f30:	18bfe51e 	bne	r3,r2,8300ec8 <altera_avalon_jtag_uart_irq+0x140>
      }

      if (space > 0)
 8300f34:	e0bffe17 	ldw	r2,-8(fp)
 8300f38:	103f9d26 	beq	r2,zero,8300db0 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 8300f3c:	e0bffd17 	ldw	r2,-12(fp)
 8300f40:	10c00817 	ldw	r3,32(r2)
 8300f44:	00bfff44 	movi	r2,-3
 8300f48:	1886703a 	and	r3,r3,r2
 8300f4c:	e0bffd17 	ldw	r2,-12(fp)
 8300f50:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 8300f54:	e0bffd17 	ldw	r2,-12(fp)
 8300f58:	10800017 	ldw	r2,0(r2)
 8300f5c:	10800104 	addi	r2,r2,4
 8300f60:	1007883a 	mov	r3,r2
 8300f64:	e0bffd17 	ldw	r2,-12(fp)
 8300f68:	10800817 	ldw	r2,32(r2)
 8300f6c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 8300f70:	e0bffc17 	ldw	r2,-16(fp)
 8300f74:	10800104 	addi	r2,r2,4
 8300f78:	10800037 	ldwio	r2,0(r2)
  {
 8300f7c:	003f8c06 	br	8300db0 <altera_avalon_jtag_uart_irq+0x28>
      break;
 8300f80:	0001883a 	nop
      }
    }
  }
}
 8300f84:	0001883a 	nop
 8300f88:	e037883a 	mov	sp,fp
 8300f8c:	df000017 	ldw	fp,0(sp)
 8300f90:	dec00104 	addi	sp,sp,4
 8300f94:	f800283a 	ret

08300f98 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 8300f98:	defffc04 	addi	sp,sp,-16
 8300f9c:	df000315 	stw	fp,12(sp)
 8300fa0:	df000304 	addi	fp,sp,12
 8300fa4:	e13ffd15 	stw	r4,-12(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 8300fa8:	e0bffd17 	ldw	r2,-12(fp)
 8300fac:	e0bfff15 	stw	r2,-4(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 8300fb0:	e0bfff17 	ldw	r2,-4(fp)
 8300fb4:	10800017 	ldw	r2,0(r2)
 8300fb8:	10800104 	addi	r2,r2,4
 8300fbc:	10800037 	ldwio	r2,0(r2)
 8300fc0:	e0bffe15 	stw	r2,-8(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 8300fc4:	e0bffe17 	ldw	r2,-8(fp)
 8300fc8:	1081000c 	andi	r2,r2,1024
 8300fcc:	10000b26 	beq	r2,zero,8300ffc <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 8300fd0:	e0bfff17 	ldw	r2,-4(fp)
 8300fd4:	10800017 	ldw	r2,0(r2)
 8300fd8:	10800104 	addi	r2,r2,4
 8300fdc:	1007883a 	mov	r3,r2
 8300fe0:	e0bfff17 	ldw	r2,-4(fp)
 8300fe4:	10800817 	ldw	r2,32(r2)
 8300fe8:	10810014 	ori	r2,r2,1024
 8300fec:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 8300ff0:	e0bfff17 	ldw	r2,-4(fp)
 8300ff4:	10000915 	stw	zero,36(r2)
 8300ff8:	00000a06 	br	8301024 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 8300ffc:	e0bfff17 	ldw	r2,-4(fp)
 8301000:	10c00917 	ldw	r3,36(r2)
 8301004:	00a00034 	movhi	r2,32768
 8301008:	10bfff04 	addi	r2,r2,-4
 830100c:	10c00536 	bltu	r2,r3,8301024 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 8301010:	e0bfff17 	ldw	r2,-4(fp)
 8301014:	10800917 	ldw	r2,36(r2)
 8301018:	10c00044 	addi	r3,r2,1
 830101c:	e0bfff17 	ldw	r2,-4(fp)
 8301020:	10c00915 	stw	r3,36(r2)
 8301024:	d0a5e917 	ldw	r2,-26716(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 8301028:	e037883a 	mov	sp,fp
 830102c:	df000017 	ldw	fp,0(sp)
 8301030:	dec00104 	addi	sp,sp,4
 8301034:	f800283a 	ret

08301038 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 8301038:	defffd04 	addi	sp,sp,-12
 830103c:	df000215 	stw	fp,8(sp)
 8301040:	df000204 	addi	fp,sp,8
 8301044:	e13fff15 	stw	r4,-4(fp)
 8301048:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 830104c:	00000506 	br	8301064 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 8301050:	e0bffe17 	ldw	r2,-8(fp)
 8301054:	1090000c 	andi	r2,r2,16384
 8301058:	10000226 	beq	r2,zero,8301064 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 830105c:	00bffd44 	movi	r2,-11
 8301060:	00000b06 	br	8301090 <altera_avalon_jtag_uart_close+0x58>
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 8301064:	e0bfff17 	ldw	r2,-4(fp)
 8301068:	10c00d17 	ldw	r3,52(r2)
 830106c:	e0bfff17 	ldw	r2,-4(fp)
 8301070:	10800c17 	ldw	r2,48(r2)
 8301074:	18800526 	beq	r3,r2,830108c <altera_avalon_jtag_uart_close+0x54>
 8301078:	e0bfff17 	ldw	r2,-4(fp)
 830107c:	10c00917 	ldw	r3,36(r2)
 8301080:	e0bfff17 	ldw	r2,-4(fp)
 8301084:	10800117 	ldw	r2,4(r2)
 8301088:	18bff136 	bltu	r3,r2,8301050 <altera_avalon_jtag_uart_close+0x18>
    }
  }

  return 0;
 830108c:	0005883a 	mov	r2,zero
}
 8301090:	e037883a 	mov	sp,fp
 8301094:	df000017 	ldw	fp,0(sp)
 8301098:	dec00104 	addi	sp,sp,4
 830109c:	f800283a 	ret

083010a0 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 83010a0:	defffa04 	addi	sp,sp,-24
 83010a4:	df000515 	stw	fp,20(sp)
 83010a8:	df000504 	addi	fp,sp,20
 83010ac:	e13ffd15 	stw	r4,-12(fp)
 83010b0:	e17ffc15 	stw	r5,-16(fp)
 83010b4:	e1bffb15 	stw	r6,-20(fp)
  int rc = -ENOTTY;
 83010b8:	00bff9c4 	movi	r2,-25
 83010bc:	e0bfff15 	stw	r2,-4(fp)

  switch (req)
 83010c0:	e0bffc17 	ldw	r2,-16(fp)
 83010c4:	109a8060 	cmpeqi	r2,r2,27137
 83010c8:	1000041e 	bne	r2,zero,83010dc <altera_avalon_jtag_uart_ioctl+0x3c>
 83010cc:	e0bffc17 	ldw	r2,-16(fp)
 83010d0:	109a80a0 	cmpeqi	r2,r2,27138
 83010d4:	1000181e 	bne	r2,zero,8301138 <altera_avalon_jtag_uart_ioctl+0x98>
      rc = 0;
    }
    break;

  default:
    break;
 83010d8:	00002906 	br	8301180 <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
 83010dc:	e0bffd17 	ldw	r2,-12(fp)
 83010e0:	10c00117 	ldw	r3,4(r2)
 83010e4:	00a00034 	movhi	r2,32768
 83010e8:	10bfffc4 	addi	r2,r2,-1
 83010ec:	18802126 	beq	r3,r2,8301174 <altera_avalon_jtag_uart_ioctl+0xd4>
      int timeout = *((int *)arg);
 83010f0:	e0bffb17 	ldw	r2,-20(fp)
 83010f4:	10800017 	ldw	r2,0(r2)
 83010f8:	e0bffe15 	stw	r2,-8(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 83010fc:	e0bffe17 	ldw	r2,-8(fp)
 8301100:	10800090 	cmplti	r2,r2,2
 8301104:	1000061e 	bne	r2,zero,8301120 <altera_avalon_jtag_uart_ioctl+0x80>
 8301108:	e0fffe17 	ldw	r3,-8(fp)
 830110c:	00a00034 	movhi	r2,32768
 8301110:	10bfffc4 	addi	r2,r2,-1
 8301114:	18800226 	beq	r3,r2,8301120 <altera_avalon_jtag_uart_ioctl+0x80>
 8301118:	e0bffe17 	ldw	r2,-8(fp)
 830111c:	00000206 	br	8301128 <altera_avalon_jtag_uart_ioctl+0x88>
 8301120:	00a00034 	movhi	r2,32768
 8301124:	10bfff84 	addi	r2,r2,-2
 8301128:	e0fffd17 	ldw	r3,-12(fp)
 830112c:	18800115 	stw	r2,4(r3)
      rc = 0;
 8301130:	e03fff15 	stw	zero,-4(fp)
    break;
 8301134:	00000f06 	br	8301174 <altera_avalon_jtag_uart_ioctl+0xd4>
    if (sp->timeout != INT_MAX)
 8301138:	e0bffd17 	ldw	r2,-12(fp)
 830113c:	10c00117 	ldw	r3,4(r2)
 8301140:	00a00034 	movhi	r2,32768
 8301144:	10bfffc4 	addi	r2,r2,-1
 8301148:	18800c26 	beq	r3,r2,830117c <altera_avalon_jtag_uart_ioctl+0xdc>
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 830114c:	e0bffd17 	ldw	r2,-12(fp)
 8301150:	10c00917 	ldw	r3,36(r2)
 8301154:	e0bffd17 	ldw	r2,-12(fp)
 8301158:	10800117 	ldw	r2,4(r2)
 830115c:	1885803a 	cmpltu	r2,r3,r2
 8301160:	10c03fcc 	andi	r3,r2,255
 8301164:	e0bffb17 	ldw	r2,-20(fp)
 8301168:	10c00015 	stw	r3,0(r2)
      rc = 0;
 830116c:	e03fff15 	stw	zero,-4(fp)
    break;
 8301170:	00000206 	br	830117c <altera_avalon_jtag_uart_ioctl+0xdc>
    break;
 8301174:	0001883a 	nop
 8301178:	00000106 	br	8301180 <altera_avalon_jtag_uart_ioctl+0xe0>
    break;
 830117c:	0001883a 	nop
  }

  return rc;
 8301180:	e0bfff17 	ldw	r2,-4(fp)
}
 8301184:	e037883a 	mov	sp,fp
 8301188:	df000017 	ldw	fp,0(sp)
 830118c:	dec00104 	addi	sp,sp,4
 8301190:	f800283a 	ret

08301194 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 8301194:	defff304 	addi	sp,sp,-52
 8301198:	dfc00c15 	stw	ra,48(sp)
 830119c:	df000b15 	stw	fp,44(sp)
 83011a0:	df000b04 	addi	fp,sp,44
 83011a4:	e13ff815 	stw	r4,-32(fp)
 83011a8:	e17ff715 	stw	r5,-36(fp)
 83011ac:	e1bff615 	stw	r6,-40(fp)
 83011b0:	e1fff515 	stw	r7,-44(fp)
  char * ptr = buffer;
 83011b4:	e0bff717 	ldw	r2,-36(fp)
 83011b8:	e0bfff15 	stw	r2,-4(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 83011bc:	00004706 	br	83012dc <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 83011c0:	e0bff817 	ldw	r2,-32(fp)
 83011c4:	10800a17 	ldw	r2,40(r2)
 83011c8:	e0bffd15 	stw	r2,-12(fp)
      out = sp->rx_out;
 83011cc:	e0bff817 	ldw	r2,-32(fp)
 83011d0:	10800b17 	ldw	r2,44(r2)
 83011d4:	e0bffc15 	stw	r2,-16(fp)

      if (in >= out)
 83011d8:	e0fffd17 	ldw	r3,-12(fp)
 83011dc:	e0bffc17 	ldw	r2,-16(fp)
 83011e0:	18800536 	bltu	r3,r2,83011f8 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 83011e4:	e0fffd17 	ldw	r3,-12(fp)
 83011e8:	e0bffc17 	ldw	r2,-16(fp)
 83011ec:	1885c83a 	sub	r2,r3,r2
 83011f0:	e0bffe15 	stw	r2,-8(fp)
 83011f4:	00000406 	br	8301208 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 83011f8:	00c20004 	movi	r3,2048
 83011fc:	e0bffc17 	ldw	r2,-16(fp)
 8301200:	1885c83a 	sub	r2,r3,r2
 8301204:	e0bffe15 	stw	r2,-8(fp)

      if (n == 0)
 8301208:	e0bffe17 	ldw	r2,-8(fp)
 830120c:	10001e26 	beq	r2,zero,8301288 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
 8301210:	e0fff617 	ldw	r3,-40(fp)
 8301214:	e0bffe17 	ldw	r2,-8(fp)
 8301218:	1880022e 	bgeu	r3,r2,8301224 <altera_avalon_jtag_uart_read+0x90>
        n = space;
 830121c:	e0bff617 	ldw	r2,-40(fp)
 8301220:	e0bffe15 	stw	r2,-8(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 8301224:	e0bff817 	ldw	r2,-32(fp)
 8301228:	10c00e04 	addi	r3,r2,56
 830122c:	e0bffc17 	ldw	r2,-16(fp)
 8301230:	1885883a 	add	r2,r3,r2
 8301234:	e1bffe17 	ldw	r6,-8(fp)
 8301238:	100b883a 	mov	r5,r2
 830123c:	e13fff17 	ldw	r4,-4(fp)
 8301240:	83035b80 	call	83035b8 <memcpy>
      ptr   += n;
 8301244:	e0ffff17 	ldw	r3,-4(fp)
 8301248:	e0bffe17 	ldw	r2,-8(fp)
 830124c:	1885883a 	add	r2,r3,r2
 8301250:	e0bfff15 	stw	r2,-4(fp)
      space -= n;
 8301254:	e0fff617 	ldw	r3,-40(fp)
 8301258:	e0bffe17 	ldw	r2,-8(fp)
 830125c:	1885c83a 	sub	r2,r3,r2
 8301260:	e0bff615 	stw	r2,-40(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 8301264:	e0fffc17 	ldw	r3,-16(fp)
 8301268:	e0bffe17 	ldw	r2,-8(fp)
 830126c:	1885883a 	add	r2,r3,r2
 8301270:	10c1ffcc 	andi	r3,r2,2047
 8301274:	e0bff817 	ldw	r2,-32(fp)
 8301278:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 830127c:	e0bff617 	ldw	r2,-40(fp)
 8301280:	00bfcf16 	blt	zero,r2,83011c0 <altera_avalon_jtag_uart_read+0x2c>
 8301284:	00000106 	br	830128c <altera_avalon_jtag_uart_read+0xf8>
        break; /* No more data available */
 8301288:	0001883a 	nop

    /* If we read any data then return it */
    if (ptr != buffer)
 830128c:	e0ffff17 	ldw	r3,-4(fp)
 8301290:	e0bff717 	ldw	r2,-36(fp)
 8301294:	1880141e 	bne	r3,r2,83012e8 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 8301298:	e0bff517 	ldw	r2,-44(fp)
 830129c:	1090000c 	andi	r2,r2,16384
 83012a0:	1000131e 	bne	r2,zero,83012f0 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 83012a4:	0001883a 	nop
 83012a8:	e0bff817 	ldw	r2,-32(fp)
 83012ac:	10800a17 	ldw	r2,40(r2)
 83012b0:	e0fffd17 	ldw	r3,-12(fp)
 83012b4:	1880051e 	bne	r3,r2,83012cc <altera_avalon_jtag_uart_read+0x138>
 83012b8:	e0bff817 	ldw	r2,-32(fp)
 83012bc:	10c00917 	ldw	r3,36(r2)
 83012c0:	e0bff817 	ldw	r2,-32(fp)
 83012c4:	10800117 	ldw	r2,4(r2)
 83012c8:	18bff736 	bltu	r3,r2,83012a8 <altera_avalon_jtag_uart_read+0x114>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 83012cc:	e0bff817 	ldw	r2,-32(fp)
 83012d0:	10800a17 	ldw	r2,40(r2)
 83012d4:	e0fffd17 	ldw	r3,-12(fp)
 83012d8:	18800726 	beq	r3,r2,83012f8 <altera_avalon_jtag_uart_read+0x164>
  while (space > 0)
 83012dc:	e0bff617 	ldw	r2,-40(fp)
 83012e0:	00bfb716 	blt	zero,r2,83011c0 <altera_avalon_jtag_uart_read+0x2c>
 83012e4:	00000506 	br	83012fc <altera_avalon_jtag_uart_read+0x168>
      break;
 83012e8:	0001883a 	nop
 83012ec:	00000306 	br	83012fc <altera_avalon_jtag_uart_read+0x168>
      break;
 83012f0:	0001883a 	nop
 83012f4:	00000106 	br	83012fc <altera_avalon_jtag_uart_read+0x168>
      break;
 83012f8:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 83012fc:	e0ffff17 	ldw	r3,-4(fp)
 8301300:	e0bff717 	ldw	r2,-36(fp)
 8301304:	18801926 	beq	r3,r2,830136c <altera_avalon_jtag_uart_read+0x1d8>
  NIOS2_READ_STATUS (context);
 8301308:	0005303a 	rdctl	r2,status
 830130c:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8301310:	e0fff917 	ldw	r3,-28(fp)
 8301314:	00bfff84 	movi	r2,-2
 8301318:	1884703a 	and	r2,r3,r2
 830131c:	1001703a 	wrctl	status,r2
  return context;
 8301320:	e0bff917 	ldw	r2,-28(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 8301324:	e0bffb15 	stw	r2,-20(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 8301328:	e0bff817 	ldw	r2,-32(fp)
 830132c:	10800817 	ldw	r2,32(r2)
 8301330:	10c00054 	ori	r3,r2,1
 8301334:	e0bff817 	ldw	r2,-32(fp)
 8301338:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 830133c:	e0bff817 	ldw	r2,-32(fp)
 8301340:	10800017 	ldw	r2,0(r2)
 8301344:	10800104 	addi	r2,r2,4
 8301348:	1007883a 	mov	r3,r2
 830134c:	e0bff817 	ldw	r2,-32(fp)
 8301350:	10800817 	ldw	r2,32(r2)
 8301354:	18800035 	stwio	r2,0(r3)
 8301358:	e0bffb17 	ldw	r2,-20(fp)
 830135c:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
 8301360:	e0bffa17 	ldw	r2,-24(fp)
 8301364:	1001703a 	wrctl	status,r2
}
 8301368:	0001883a 	nop
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 830136c:	e0ffff17 	ldw	r3,-4(fp)
 8301370:	e0bff717 	ldw	r2,-36(fp)
 8301374:	18800426 	beq	r3,r2,8301388 <altera_avalon_jtag_uart_read+0x1f4>
    return ptr - buffer;
 8301378:	e0ffff17 	ldw	r3,-4(fp)
 830137c:	e0bff717 	ldw	r2,-36(fp)
 8301380:	1885c83a 	sub	r2,r3,r2
 8301384:	00000606 	br	83013a0 <altera_avalon_jtag_uart_read+0x20c>
  else if (flags & O_NONBLOCK)
 8301388:	e0bff517 	ldw	r2,-44(fp)
 830138c:	1090000c 	andi	r2,r2,16384
 8301390:	10000226 	beq	r2,zero,830139c <altera_avalon_jtag_uart_read+0x208>
    return -EWOULDBLOCK;
 8301394:	00bffd44 	movi	r2,-11
 8301398:	00000106 	br	83013a0 <altera_avalon_jtag_uart_read+0x20c>
  else
    return -EIO;
 830139c:	00bffec4 	movi	r2,-5
}
 83013a0:	e037883a 	mov	sp,fp
 83013a4:	dfc00117 	ldw	ra,4(sp)
 83013a8:	df000017 	ldw	fp,0(sp)
 83013ac:	dec00204 	addi	sp,sp,8
 83013b0:	f800283a 	ret

083013b4 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 83013b4:	defff304 	addi	sp,sp,-52
 83013b8:	dfc00c15 	stw	ra,48(sp)
 83013bc:	df000b15 	stw	fp,44(sp)
 83013c0:	df000b04 	addi	fp,sp,44
 83013c4:	e13ff815 	stw	r4,-32(fp)
 83013c8:	e17ff715 	stw	r5,-36(fp)
 83013cc:	e1bff615 	stw	r6,-40(fp)
 83013d0:	e1fff515 	stw	r7,-44(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 83013d4:	e03fff15 	stw	zero,-4(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 83013d8:	e0bff717 	ldw	r2,-36(fp)
 83013dc:	e0bffd15 	stw	r2,-12(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 83013e0:	00003706 	br	83014c0 <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 83013e4:	e0bff817 	ldw	r2,-32(fp)
 83013e8:	10800c17 	ldw	r2,48(r2)
 83013ec:	e0bffc15 	stw	r2,-16(fp)
      out = sp->tx_out;
 83013f0:	e0bff817 	ldw	r2,-32(fp)
 83013f4:	10800d17 	ldw	r2,52(r2)
 83013f8:	e0bfff15 	stw	r2,-4(fp)

      if (in < out)
 83013fc:	e0fffc17 	ldw	r3,-16(fp)
 8301400:	e0bfff17 	ldw	r2,-4(fp)
 8301404:	1880062e 	bgeu	r3,r2,8301420 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 8301408:	e0ffff17 	ldw	r3,-4(fp)
 830140c:	e0bffc17 	ldw	r2,-16(fp)
 8301410:	1885c83a 	sub	r2,r3,r2
 8301414:	10bfffc4 	addi	r2,r2,-1
 8301418:	e0bffe15 	stw	r2,-8(fp)
 830141c:	00000b06 	br	830144c <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 8301420:	e0bfff17 	ldw	r2,-4(fp)
 8301424:	10000526 	beq	r2,zero,830143c <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 8301428:	00c20004 	movi	r3,2048
 830142c:	e0bffc17 	ldw	r2,-16(fp)
 8301430:	1885c83a 	sub	r2,r3,r2
 8301434:	e0bffe15 	stw	r2,-8(fp)
 8301438:	00000406 	br	830144c <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 830143c:	00c1ffc4 	movi	r3,2047
 8301440:	e0bffc17 	ldw	r2,-16(fp)
 8301444:	1885c83a 	sub	r2,r3,r2
 8301448:	e0bffe15 	stw	r2,-8(fp)

      if (n == 0)
 830144c:	e0bffe17 	ldw	r2,-8(fp)
 8301450:	10001e26 	beq	r2,zero,83014cc <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
 8301454:	e0fff617 	ldw	r3,-40(fp)
 8301458:	e0bffe17 	ldw	r2,-8(fp)
 830145c:	1880022e 	bgeu	r3,r2,8301468 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
 8301460:	e0bff617 	ldw	r2,-40(fp)
 8301464:	e0bffe15 	stw	r2,-8(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 8301468:	e0bff817 	ldw	r2,-32(fp)
 830146c:	10c20e04 	addi	r3,r2,2104
 8301470:	e0bffc17 	ldw	r2,-16(fp)
 8301474:	1885883a 	add	r2,r3,r2
 8301478:	e1bffe17 	ldw	r6,-8(fp)
 830147c:	e17ff717 	ldw	r5,-36(fp)
 8301480:	1009883a 	mov	r4,r2
 8301484:	83035b80 	call	83035b8 <memcpy>
      ptr   += n;
 8301488:	e0fff717 	ldw	r3,-36(fp)
 830148c:	e0bffe17 	ldw	r2,-8(fp)
 8301490:	1885883a 	add	r2,r3,r2
 8301494:	e0bff715 	stw	r2,-36(fp)
      count -= n;
 8301498:	e0fff617 	ldw	r3,-40(fp)
 830149c:	e0bffe17 	ldw	r2,-8(fp)
 83014a0:	1885c83a 	sub	r2,r3,r2
 83014a4:	e0bff615 	stw	r2,-40(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 83014a8:	e0fffc17 	ldw	r3,-16(fp)
 83014ac:	e0bffe17 	ldw	r2,-8(fp)
 83014b0:	1885883a 	add	r2,r3,r2
 83014b4:	10c1ffcc 	andi	r3,r2,2047
 83014b8:	e0bff817 	ldw	r2,-32(fp)
 83014bc:	10c00c15 	stw	r3,48(r2)
    while (count > 0)
 83014c0:	e0bff617 	ldw	r2,-40(fp)
 83014c4:	00bfc716 	blt	zero,r2,83013e4 <altera_avalon_jtag_uart_write+0x30>
 83014c8:	00000106 	br	83014d0 <altera_avalon_jtag_uart_write+0x11c>
        break;
 83014cc:	0001883a 	nop
  NIOS2_READ_STATUS (context);
 83014d0:	0005303a 	rdctl	r2,status
 83014d4:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 83014d8:	e0fff917 	ldw	r3,-28(fp)
 83014dc:	00bfff84 	movi	r2,-2
 83014e0:	1884703a 	and	r2,r3,r2
 83014e4:	1001703a 	wrctl	status,r2
  return context;
 83014e8:	e0bff917 	ldw	r2,-28(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 83014ec:	e0bffb15 	stw	r2,-20(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 83014f0:	e0bff817 	ldw	r2,-32(fp)
 83014f4:	10800817 	ldw	r2,32(r2)
 83014f8:	10c00094 	ori	r3,r2,2
 83014fc:	e0bff817 	ldw	r2,-32(fp)
 8301500:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 8301504:	e0bff817 	ldw	r2,-32(fp)
 8301508:	10800017 	ldw	r2,0(r2)
 830150c:	10800104 	addi	r2,r2,4
 8301510:	1007883a 	mov	r3,r2
 8301514:	e0bff817 	ldw	r2,-32(fp)
 8301518:	10800817 	ldw	r2,32(r2)
 830151c:	18800035 	stwio	r2,0(r3)
 8301520:	e0bffb17 	ldw	r2,-20(fp)
 8301524:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
 8301528:	e0bffa17 	ldw	r2,-24(fp)
 830152c:	1001703a 	wrctl	status,r2
}
 8301530:	0001883a 	nop
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 8301534:	e0bff617 	ldw	r2,-40(fp)
 8301538:	0080100e 	bge	zero,r2,830157c <altera_avalon_jtag_uart_write+0x1c8>
    {
      if (flags & O_NONBLOCK)
 830153c:	e0bff517 	ldw	r2,-44(fp)
 8301540:	1090000c 	andi	r2,r2,16384
 8301544:	1000101e 	bne	r2,zero,8301588 <altera_avalon_jtag_uart_write+0x1d4>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 8301548:	0001883a 	nop
 830154c:	e0bff817 	ldw	r2,-32(fp)
 8301550:	10800d17 	ldw	r2,52(r2)
 8301554:	e0ffff17 	ldw	r3,-4(fp)
 8301558:	1880051e 	bne	r3,r2,8301570 <altera_avalon_jtag_uart_write+0x1bc>
 830155c:	e0bff817 	ldw	r2,-32(fp)
 8301560:	10c00917 	ldw	r3,36(r2)
 8301564:	e0bff817 	ldw	r2,-32(fp)
 8301568:	10800117 	ldw	r2,4(r2)
 830156c:	18bff736 	bltu	r3,r2,830154c <altera_avalon_jtag_uart_write+0x198>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 8301570:	e0bff817 	ldw	r2,-32(fp)
 8301574:	10800917 	ldw	r2,36(r2)
 8301578:	1000051e 	bne	r2,zero,8301590 <altera_avalon_jtag_uart_write+0x1dc>
         break;
    }
  }
  while (count > 0);
 830157c:	e0bff617 	ldw	r2,-40(fp)
 8301580:	00bfcf16 	blt	zero,r2,83014c0 <altera_avalon_jtag_uart_write+0x10c>
 8301584:	00000306 	br	8301594 <altera_avalon_jtag_uart_write+0x1e0>
        break;
 8301588:	0001883a 	nop
 830158c:	00000106 	br	8301594 <altera_avalon_jtag_uart_write+0x1e0>
         break;
 8301590:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 8301594:	e0fff717 	ldw	r3,-36(fp)
 8301598:	e0bffd17 	ldw	r2,-12(fp)
 830159c:	18800426 	beq	r3,r2,83015b0 <altera_avalon_jtag_uart_write+0x1fc>
    return ptr - start;
 83015a0:	e0fff717 	ldw	r3,-36(fp)
 83015a4:	e0bffd17 	ldw	r2,-12(fp)
 83015a8:	1885c83a 	sub	r2,r3,r2
 83015ac:	00000606 	br	83015c8 <altera_avalon_jtag_uart_write+0x214>
  else if (flags & O_NONBLOCK)
 83015b0:	e0bff517 	ldw	r2,-44(fp)
 83015b4:	1090000c 	andi	r2,r2,16384
 83015b8:	10000226 	beq	r2,zero,83015c4 <altera_avalon_jtag_uart_write+0x210>
    return -EWOULDBLOCK;
 83015bc:	00bffd44 	movi	r2,-11
 83015c0:	00000106 	br	83015c8 <altera_avalon_jtag_uart_write+0x214>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 83015c4:	00bffec4 	movi	r2,-5
}
 83015c8:	e037883a 	mov	sp,fp
 83015cc:	dfc00117 	ldw	ra,4(sp)
 83015d0:	df000017 	ldw	fp,0(sp)
 83015d4:	dec00204 	addi	sp,sp,8
 83015d8:	f800283a 	ret

083015dc <altera_avalon_mailbox_identify>:
 * Check an instance open match
 * with the callback register
 */

static void altera_avalon_mailbox_identify (altera_avalon_mailbox_dev *dev)
{
 83015dc:	defffd04 	addi	sp,sp,-12
 83015e0:	df000215 	stw	fp,8(sp)
 83015e4:	df000204 	addi	fp,sp,8
 83015e8:	e13ffe15 	stw	r4,-8(fp)
    /* Random signature to test mailbox ownership */
    alt_u32 magic_num = 0x3A11B045;
 83015ec:	008e84b4 	movhi	r2,14866
 83015f0:	10ac1144 	addi	r2,r2,-20411
 83015f4:	e0bfff15 	stw	r2,-4(fp)

    IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, magic_num);
 83015f8:	e0bffe17 	ldw	r2,-8(fp)
 83015fc:	10800a17 	ldw	r2,40(r2)
 8301600:	10800104 	addi	r2,r2,4
 8301604:	1007883a 	mov	r3,r2
 8301608:	e0bfff17 	ldw	r2,-4(fp)
 830160c:	18800035 	stwio	r2,0(r3)
    if((IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST)) == magic_num)
 8301610:	e0bffe17 	ldw	r2,-8(fp)
 8301614:	10800a17 	ldw	r2,40(r2)
 8301618:	10800104 	addi	r2,r2,4
 830161c:	10c00037 	ldwio	r3,0(r2)
 8301620:	e0bfff17 	ldw	r2,-4(fp)
 8301624:	1880081e 	bne	r3,r2,8301648 <altera_avalon_mailbox_identify+0x6c>
    {
        dev-> mbox_type = MBOX_TX;
 8301628:	e0bffe17 	ldw	r2,-8(fp)
 830162c:	10000f15 	stw	zero,60(r2)
        /* Clear message_ptr to default */
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, 0x0);
 8301630:	e0bffe17 	ldw	r2,-8(fp)
 8301634:	10800a17 	ldw	r2,40(r2)
 8301638:	10800104 	addi	r2,r2,4
 830163c:	0007883a 	mov	r3,zero
 8301640:	10c00035 	stwio	r3,0(r2)
    } else
    {
	    dev->mbox_type = MBOX_RX;
    }
}
 8301644:	00000306 	br	8301654 <altera_avalon_mailbox_identify+0x78>
	    dev->mbox_type = MBOX_RX;
 8301648:	e0bffe17 	ldw	r2,-8(fp)
 830164c:	00c00044 	movi	r3,1
 8301650:	10c00f15 	stw	r3,60(r2)
}
 8301654:	0001883a 	nop
 8301658:	e037883a 	mov	sp,fp
 830165c:	df000017 	ldw	fp,0(sp)
 8301660:	dec00104 	addi	sp,sp,4
 8301664:	f800283a 	ret

08301668 <altera_avalon_mailbox_post>:
/*
 *   altera_avalon_mailbox_post
 *   This function post message out through sender mailbox
 */
static alt_32 altera_avalon_mailbox_post (altera_avalon_mailbox_dev *dev,  void *message)
{
 8301668:	defffc04 	addi	sp,sp,-16
 830166c:	df000315 	stw	fp,12(sp)
 8301670:	df000304 	addi	fp,sp,12
 8301674:	e13ffe15 	stw	r4,-8(fp)
 8301678:	e17ffd15 	stw	r5,-12(fp)
    alt_u32 *mbox_msg = (alt_u32*) message ;
 830167c:	e0bffd17 	ldw	r2,-12(fp)
 8301680:	e0bfff15 	stw	r2,-4(fp)

    if (mbox_msg != NULL) {
 8301684:	e0bfff17 	ldw	r2,-4(fp)
 8301688:	10001026 	beq	r2,zero,83016cc <altera_avalon_mailbox_post+0x64>
        /* When message space available, post the message out */
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, mbox_msg[1]);
 830168c:	e0bffe17 	ldw	r2,-8(fp)
 8301690:	10800a17 	ldw	r2,40(r2)
 8301694:	10800104 	addi	r2,r2,4
 8301698:	1007883a 	mov	r3,r2
 830169c:	e0bfff17 	ldw	r2,-4(fp)
 83016a0:	10800104 	addi	r2,r2,4
 83016a4:	10800017 	ldw	r2,0(r2)
 83016a8:	18800035 	stwio	r2,0(r3)
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST, mbox_msg[0]);
 83016ac:	e0bffe17 	ldw	r2,-8(fp)
 83016b0:	10800a17 	ldw	r2,40(r2)
 83016b4:	1007883a 	mov	r3,r2
 83016b8:	e0bfff17 	ldw	r2,-4(fp)
 83016bc:	10800017 	ldw	r2,0(r2)
 83016c0:	18800035 	stwio	r2,0(r3)
        return 0;
 83016c4:	0005883a 	mov	r2,zero
 83016c8:	00000106 	br	83016d0 <altera_avalon_mailbox_post+0x68>
    }
    /* Invalid NULL message received */
    return -EINVAL;
 83016cc:	00bffa84 	movi	r2,-22
}
 83016d0:	e037883a 	mov	sp,fp
 83016d4:	df000017 	ldw	fp,0(sp)
 83016d8:	dec00104 	addi	sp,sp,4
 83016dc:	f800283a 	ret

083016e0 <altera_avalon_mailbox_simple_tx_isr>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_mailbox_simple_tx_isr(void *context)
#else
static void altera_avalon_mailbox_simple_tx_isr(void *context, alt_u32 id)
#endif
{
 83016e0:	defff504 	addi	sp,sp,-44
 83016e4:	dfc00a15 	stw	ra,40(sp)
 83016e8:	df000915 	stw	fp,36(sp)
 83016ec:	df000904 	addi	fp,sp,36
 83016f0:	e13ff815 	stw	r4,-32(fp)
 83016f4:	e17ff715 	stw	r5,-36(fp)
    altera_avalon_mailbox_dev *dev = (altera_avalon_mailbox_dev*) context;
 83016f8:	e0bff817 	ldw	r2,-32(fp)
 83016fc:	e0bfff15 	stw	r2,-4(fp)
    int status = 0;
 8301700:	e03ffe15 	stw	zero,-8(fp)
    alt_u32 data;
    alt_irq_context cpu_sr;
    alt_u32 *message = dev->mbox_msg;
 8301704:	e0bfff17 	ldw	r2,-4(fp)
 8301708:	10801017 	ldw	r2,64(r2)
 830170c:	e0bffd15 	stw	r2,-12(fp)

    /* Mask mailbox interrupt */
    data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) &
 8301710:	e0bfff17 	ldw	r2,-4(fp)
 8301714:	10800a17 	ldw	r2,40(r2)
 8301718:	10800304 	addi	r2,r2,12
 830171c:	10800037 	ldwio	r2,0(r2)
 8301720:	1007883a 	mov	r3,r2
 8301724:	00bfff44 	movi	r2,-3
 8301728:	1884703a 	and	r2,r3,r2
 830172c:	e0bffc15 	stw	r2,-16(fp)
               (~ALTERA_AVALON_MAILBOX_SIMPLE_INTR_SPACE_MSK);
    IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
 8301730:	e0bfff17 	ldw	r2,-4(fp)
 8301734:	10800a17 	ldw	r2,40(r2)
 8301738:	10800304 	addi	r2,r2,12
 830173c:	1007883a 	mov	r3,r2
 8301740:	e0bffc17 	ldw	r2,-16(fp)
 8301744:	18800035 	stwio	r2,0(r3)

    if (message != NULL)
 8301748:	e0bffd17 	ldw	r2,-12(fp)
 830174c:	10002e26 	beq	r2,zero,8301808 <altera_avalon_mailbox_simple_tx_isr+0x128>
    {
        /* Post out message requested */
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST, message[1]);
 8301750:	e0bfff17 	ldw	r2,-4(fp)
 8301754:	10800a17 	ldw	r2,40(r2)
 8301758:	10800104 	addi	r2,r2,4
 830175c:	1007883a 	mov	r3,r2
 8301760:	e0bffd17 	ldw	r2,-12(fp)
 8301764:	10800104 	addi	r2,r2,4
 8301768:	10800017 	ldw	r2,0(r2)
 830176c:	18800035 	stwio	r2,0(r3)
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST, message[0]);
 8301770:	e0bfff17 	ldw	r2,-4(fp)
 8301774:	10800a17 	ldw	r2,40(r2)
 8301778:	1007883a 	mov	r3,r2
 830177c:	e0bffd17 	ldw	r2,-12(fp)
 8301780:	10800017 	ldw	r2,0(r2)
 8301784:	18800035 	stwio	r2,0(r3)
    /*
     * Other interrupts are explicitly disabled if callbacks are registered
     * because there is no guarantee that they are preemption-safe.
     */
        status = (IORD_ALTERA_AVALON_MAILBOX_STS(dev->base)
 8301788:	e0bfff17 	ldw	r2,-4(fp)
 830178c:	10800a17 	ldw	r2,40(r2)
 8301790:	10800204 	addi	r2,r2,8
 8301794:	10800037 	ldwio	r2,0(r2)
        		  & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;
 8301798:	1005d07a 	srai	r2,r2,1
        status = (IORD_ALTERA_AVALON_MAILBOX_STS(dev->base)
 830179c:	1080004c 	andi	r2,r2,1
 83017a0:	e0bffe15 	stw	r2,-8(fp)
        if (dev->tx_cb)
 83017a4:	e0bfff17 	ldw	r2,-4(fp)
 83017a8:	10800d17 	ldw	r2,52(r2)
 83017ac:	10001226 	beq	r2,zero,83017f8 <altera_avalon_mailbox_simple_tx_isr+0x118>
  NIOS2_READ_STATUS (context);
 83017b0:	0005303a 	rdctl	r2,status
 83017b4:	e0bff915 	stw	r2,-28(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 83017b8:	e0fff917 	ldw	r3,-28(fp)
 83017bc:	00bfff84 	movi	r2,-2
 83017c0:	1884703a 	and	r2,r3,r2
 83017c4:	1001703a 	wrctl	status,r2
  return context;
 83017c8:	e0bff917 	ldw	r2,-28(fp)
        {
            cpu_sr = alt_irq_disable_all();
 83017cc:	e0bffb15 	stw	r2,-20(fp)
  	        (dev->tx_cb)(message, status);
 83017d0:	e0bfff17 	ldw	r2,-4(fp)
 83017d4:	10800d17 	ldw	r2,52(r2)
 83017d8:	e17ffe17 	ldw	r5,-8(fp)
 83017dc:	e13ffd17 	ldw	r4,-12(fp)
 83017e0:	103ee83a 	callr	r2
 83017e4:	e0bffb17 	ldw	r2,-20(fp)
 83017e8:	e0bffa15 	stw	r2,-24(fp)
  NIOS2_WRITE_STATUS (context);
 83017ec:	e0bffa17 	ldw	r2,-24(fp)
 83017f0:	1001703a 	wrctl	status,r2
}
 83017f4:	0001883a 	nop
            alt_irq_enable_all(cpu_sr);
        }
        /* Clear mailbox message to NULL after message being posted */
        dev->mbox_msg = NULL;
 83017f8:	e0bfff17 	ldw	r2,-4(fp)
 83017fc:	10001015 	stw	zero,64(r2)
        dev->lock = 0;
 8301800:	e0bfff17 	ldw	r2,-4(fp)
 8301804:	10001105 	stb	zero,68(r2)
    }
}
 8301808:	0001883a 	nop
 830180c:	e037883a 	mov	sp,fp
 8301810:	dfc00117 	ldw	ra,4(sp)
 8301814:	df000017 	ldw	fp,0(sp)
 8301818:	dec00204 	addi	sp,sp,8
 830181c:	f800283a 	ret

08301820 <altera_avalon_mailbox_simple_rx_isr>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_mailbox_simple_rx_isr(void *context)
#else
static void altera_avalon_mailbox_simple_rx_isr(void *context, alt_u32 id)
#endif
{
 8301820:	defff604 	addi	sp,sp,-40
 8301824:	dfc00915 	stw	ra,36(sp)
 8301828:	df000815 	stw	fp,32(sp)
 830182c:	df000804 	addi	fp,sp,32
 8301830:	e13ff915 	stw	r4,-28(fp)
 8301834:	e17ff815 	stw	r5,-32(fp)
    altera_avalon_mailbox_dev *dev = (altera_avalon_mailbox_dev*) context;
 8301838:	e0bff917 	ldw	r2,-28(fp)
 830183c:	e0bfff15 	stw	r2,-4(fp)
    alt_irq_context cpu_sr;
    alt_u32 inbox[2];

    inbox[1] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST));
 8301840:	e0bfff17 	ldw	r2,-4(fp)
 8301844:	10800a17 	ldw	r2,40(r2)
 8301848:	10800104 	addi	r2,r2,4
 830184c:	10800037 	ldwio	r2,0(r2)
 8301850:	e0bffb15 	stw	r2,-20(fp)
    inbox[0] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST));
 8301854:	e0bfff17 	ldw	r2,-4(fp)
 8301858:	10800a17 	ldw	r2,40(r2)
 830185c:	10800037 	ldwio	r2,0(r2)
 8301860:	e0bffa15 	stw	r2,-24(fp)

    /*
     * Other interrupts are explicitly disabled if callbacks are registered
     * because there is no guarantee that they are preemption-safe.
     */
    if (dev->rx_cb)
 8301864:	e0bfff17 	ldw	r2,-4(fp)
 8301868:	10800e17 	ldw	r2,56(r2)
 830186c:	10001226 	beq	r2,zero,83018b8 <altera_avalon_mailbox_simple_rx_isr+0x98>
  NIOS2_READ_STATUS (context);
 8301870:	0005303a 	rdctl	r2,status
 8301874:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8301878:	e0fffc17 	ldw	r3,-16(fp)
 830187c:	00bfff84 	movi	r2,-2
 8301880:	1884703a 	and	r2,r3,r2
 8301884:	1001703a 	wrctl	status,r2
  return context;
 8301888:	e0bffc17 	ldw	r2,-16(fp)
    {
        cpu_sr = alt_irq_disable_all();
 830188c:	e0bffe15 	stw	r2,-8(fp)
        (dev->rx_cb)(inbox);
 8301890:	e0bfff17 	ldw	r2,-4(fp)
 8301894:	10800e17 	ldw	r2,56(r2)
 8301898:	e0fffa04 	addi	r3,fp,-24
 830189c:	1809883a 	mov	r4,r3
 83018a0:	103ee83a 	callr	r2
 83018a4:	e0bffe17 	ldw	r2,-8(fp)
 83018a8:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context);
 83018ac:	e0bffd17 	ldw	r2,-12(fp)
 83018b0:	1001703a 	wrctl	status,r2
}
 83018b4:	0001883a 	nop
        alt_irq_enable_all(cpu_sr);
    }
}
 83018b8:	0001883a 	nop
 83018bc:	e037883a 	mov	sp,fp
 83018c0:	dfc00117 	ldw	ra,4(sp)
 83018c4:	df000017 	ldw	fp,0(sp)
 83018c8:	dec00204 	addi	sp,sp,8
 83018cc:	f800283a 	ret

083018d0 <altera_avalon_mailbox_simple_init>:
 * Altera avalon mailbox init
 * Initialize mailbox device and identify sender/receiver mailbox
 */
void altera_avalon_mailbox_simple_init (altera_avalon_mailbox_dev *dev,
		                               int intr_id, int irq)
{
 83018d0:	defffb04 	addi	sp,sp,-20
 83018d4:	dfc00415 	stw	ra,16(sp)
 83018d8:	df000315 	stw	fp,12(sp)
 83018dc:	df000304 	addi	fp,sp,12
 83018e0:	e13fff15 	stw	r4,-4(fp)
 83018e4:	e17ffe15 	stw	r5,-8(fp)
 83018e8:	e1bffd15 	stw	r6,-12(fp)
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_mailbox_simple_list);
 83018ec:	d1600104 	addi	r5,gp,-32764
 83018f0:	e13fff17 	ldw	r4,-4(fp)
 83018f4:	8302a780 	call	8302a78 <alt_dev_llist_insert>
    
    dev->mailbox_irq    = irq;
 83018f8:	e0fffd17 	ldw	r3,-12(fp)
 83018fc:	e0bfff17 	ldw	r2,-4(fp)
 8301900:	10c00b15 	stw	r3,44(r2)
    dev->mailbox_intr_ctrl_id = intr_id;
 8301904:	e0fffe17 	ldw	r3,-8(fp)
 8301908:	e0bfff17 	ldw	r2,-4(fp)
 830190c:	10c00c15 	stw	r3,48(r2)
    dev->rx_cb = NULL;
 8301910:	e0bfff17 	ldw	r2,-4(fp)
 8301914:	10000e15 	stw	zero,56(r2)
    dev->tx_cb = NULL;
 8301918:	e0bfff17 	ldw	r2,-4(fp)
 830191c:	10000d15 	stw	zero,52(r2)
    dev->mbox_msg = NULL;
 8301920:	e0bfff17 	ldw	r2,-4(fp)
 8301924:	10001015 	stw	zero,64(r2)
    
    ALT_SEM_CREATE (&dev->write_lock, 1);

    altera_avalon_mailbox_identify(dev);
 8301928:	e13fff17 	ldw	r4,-4(fp)
 830192c:	83015dc0 	call	83015dc <altera_avalon_mailbox_identify>
}
 8301930:	0001883a 	nop
 8301934:	e037883a 	mov	sp,fp
 8301938:	dfc00117 	ldw	ra,4(sp)
 830193c:	df000017 	ldw	fp,0(sp)
 8301940:	dec00204 	addi	sp,sp,8
 8301944:	f800283a 	ret

08301948 <altera_avalon_mailbox_open>:
 * Search the list of registered mailboxes for one with the supplied name.
 * The return value will be NULL on failure, and non-NULL otherwise.
 */
altera_avalon_mailbox_dev* altera_avalon_mailbox_open (const char *name,
		altera_mailbox_tx_cb tx_callback, altera_mailbox_rx_cb rx_callback)
{
 8301948:	defff904 	addi	sp,sp,-28
 830194c:	dfc00615 	stw	ra,24(sp)
 8301950:	df000515 	stw	fp,20(sp)
 8301954:	df000504 	addi	fp,sp,20
 8301958:	e13ffd15 	stw	r4,-12(fp)
 830195c:	e17ffc15 	stw	r5,-16(fp)
 8301960:	e1bffb15 	stw	r6,-20(fp)
    altera_avalon_mailbox_dev *dev;
    alt_u32 data;

    /* Find requested device */
    dev = (altera_avalon_mailbox_dev*) alt_find_dev (name, &alt_mailbox_simple_list);
 8301964:	d1600104 	addi	r5,gp,-32764
 8301968:	e13ffd17 	ldw	r4,-12(fp)
 830196c:	8302be80 	call	8302be8 <alt_find_dev>
 8301970:	e0bfff15 	stw	r2,-4(fp)
    if (dev == NULL)
 8301974:	e0bfff17 	ldw	r2,-4(fp)
 8301978:	1000021e 	bne	r2,zero,8301984 <altera_avalon_mailbox_open+0x3c>
    {
        return NULL;
 830197c:	0005883a 	mov	r2,zero
 8301980:	00005d06 	br	8301af8 <altera_avalon_mailbox_open+0x1b0>
    }

    /* Mask mailbox interrupt before ISR is being registered. */
    data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST);
 8301984:	e0bfff17 	ldw	r2,-4(fp)
 8301988:	10800a17 	ldw	r2,40(r2)
 830198c:	10800304 	addi	r2,r2,12
 8301990:	10800037 	ldwio	r2,0(r2)
 8301994:	e0bffe15 	stw	r2,-8(fp)
    if (dev->mbox_type == MBOX_TX) {
 8301998:	e0bfff17 	ldw	r2,-4(fp)
 830199c:	10800f17 	ldw	r2,60(r2)
 83019a0:	1000081e 	bne	r2,zero,83019c4 <altera_avalon_mailbox_open+0x7c>
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, \
 83019a4:	e0bfff17 	ldw	r2,-4(fp)
 83019a8:	10800a17 	ldw	r2,40(r2)
 83019ac:	10800304 	addi	r2,r2,12
 83019b0:	1009883a 	mov	r4,r2
 83019b4:	e0fffe17 	ldw	r3,-8(fp)
 83019b8:	00bfff44 	movi	r2,-3
 83019bc:	1884703a 	and	r2,r3,r2
 83019c0:	20800035 	stwio	r2,0(r4)
            (data & ~(ALTERA_AVALON_MAILBOX_SIMPLE_INTR_SPACE_MSK)));
    }
    if (dev->mbox_type == MBOX_RX) {
 83019c4:	e0bfff17 	ldw	r2,-4(fp)
 83019c8:	10800f17 	ldw	r2,60(r2)
 83019cc:	10800058 	cmpnei	r2,r2,1
 83019d0:	1000081e 	bne	r2,zero,83019f4 <altera_avalon_mailbox_open+0xac>
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, \
 83019d4:	e0bfff17 	ldw	r2,-4(fp)
 83019d8:	10800a17 	ldw	r2,40(r2)
 83019dc:	10800304 	addi	r2,r2,12
 83019e0:	1009883a 	mov	r4,r2
 83019e4:	e0fffe17 	ldw	r3,-8(fp)
 83019e8:	00bfff84 	movi	r2,-2
 83019ec:	1884703a 	and	r2,r3,r2
 83019f0:	20800035 	stwio	r2,0(r4)
    }

    /* If IRQ not connected, return device pointer without ISR register,
     * in polling mode.
     */
    if (dev->mailbox_irq == ALT_IRQ_NOT_CONNECTED)
 83019f4:	e0bfff17 	ldw	r2,-4(fp)
 83019f8:	10800b17 	ldw	r2,44(r2)
 83019fc:	10bfffd8 	cmpnei	r2,r2,-1
 8301a00:	1000021e 	bne	r2,zero,8301a0c <altera_avalon_mailbox_open+0xc4>
        return dev;
 8301a04:	e0bfff17 	ldw	r2,-4(fp)
 8301a08:	00003b06 	br	8301af8 <altera_avalon_mailbox_open+0x1b0>

    /* For IRQ connected case */

    if ((tx_callback == NULL) && (rx_callback == NULL))
 8301a0c:	e0bffc17 	ldw	r2,-16(fp)
 8301a10:	1000041e 	bne	r2,zero,8301a24 <altera_avalon_mailbox_open+0xdc>
 8301a14:	e0bffb17 	ldw	r2,-20(fp)
 8301a18:	1000021e 	bne	r2,zero,8301a24 <altera_avalon_mailbox_open+0xdc>
    {
    /* No callback, polling mode */
        return dev;
 8301a1c:	e0bfff17 	ldw	r2,-4(fp)
 8301a20:	00003506 	br	8301af8 <altera_avalon_mailbox_open+0x1b0>
    }

    /* Ensure user correctly use the mailbox
     * Return - Null if wrong direction set
     */
    if (((dev->mbox_type == MBOX_TX) && (rx_callback != NULL)) ||
 8301a24:	e0bfff17 	ldw	r2,-4(fp)
 8301a28:	10800f17 	ldw	r2,60(r2)
 8301a2c:	1000021e 	bne	r2,zero,8301a38 <altera_avalon_mailbox_open+0xf0>
 8301a30:	e0bffb17 	ldw	r2,-20(fp)
 8301a34:	1000061e 	bne	r2,zero,8301a50 <altera_avalon_mailbox_open+0x108>
	    ((dev->mbox_type == MBOX_RX) && (tx_callback != NULL)))
 8301a38:	e0bfff17 	ldw	r2,-4(fp)
 8301a3c:	10800f17 	ldw	r2,60(r2)
    if (((dev->mbox_type == MBOX_TX) && (rx_callback != NULL)) ||
 8301a40:	10800058 	cmpnei	r2,r2,1
 8301a44:	1000041e 	bne	r2,zero,8301a58 <altera_avalon_mailbox_open+0x110>
	    ((dev->mbox_type == MBOX_RX) && (tx_callback != NULL)))
 8301a48:	e0bffc17 	ldw	r2,-16(fp)
 8301a4c:	10000226 	beq	r2,zero,8301a58 <altera_avalon_mailbox_open+0x110>
  	  /* Invalid callback  */
        return NULL;
 8301a50:	0005883a 	mov	r2,zero
 8301a54:	00002806 	br	8301af8 <altera_avalon_mailbox_open+0x1b0>

    /* IRQ is valid register callback
     * to current mailbox device
     */
    dev->tx_cb  = tx_callback;
 8301a58:	e0bfff17 	ldw	r2,-4(fp)
 8301a5c:	e0fffc17 	ldw	r3,-16(fp)
 8301a60:	10c00d15 	stw	r3,52(r2)
    dev->rx_cb  = rx_callback;
 8301a64:	e0bfff17 	ldw	r2,-4(fp)
 8301a68:	e0fffb17 	ldw	r3,-20(fp)
 8301a6c:	10c00e15 	stw	r3,56(r2)

    /* Register Mailbox's ISR */
    if (dev->mbox_type == MBOX_TX)
 8301a70:	e0bfff17 	ldw	r2,-4(fp)
 8301a74:	10800f17 	ldw	r2,60(r2)
 8301a78:	1000071e 	bne	r2,zero,8301a98 <altera_avalon_mailbox_open+0x150>
    {
    #ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_ic_isr_register(dev->mailbox_intr_ctrl_id, dev->mailbox_irq, altera_avalon_mailbox_simple_tx_isr,
                            dev, NULL);
    #else
        alt_irq_register(dev->mailbox_irq, dev, altera_avalon_mailbox_simple_tx_isr);
 8301a7c:	e0bfff17 	ldw	r2,-4(fp)
 8301a80:	10800b17 	ldw	r2,44(r2)
 8301a84:	01820c34 	movhi	r6,2096
 8301a88:	3185b804 	addi	r6,r6,5856
 8301a8c:	e17fff17 	ldw	r5,-4(fp)
 8301a90:	1009883a 	mov	r4,r2
 8301a94:	83007780 	call	8300778 <alt_irq_register>
    #endif
    }
  
    if (dev->mbox_type == MBOX_RX)
 8301a98:	e0bfff17 	ldw	r2,-4(fp)
 8301a9c:	10800f17 	ldw	r2,60(r2)
 8301aa0:	10800058 	cmpnei	r2,r2,1
 8301aa4:	1000131e 	bne	r2,zero,8301af4 <altera_avalon_mailbox_open+0x1ac>
    {
    #ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_ic_isr_register(dev->mailbox_intr_ctrl_id, dev->mailbox_irq, altera_avalon_mailbox_simple_rx_isr,
                            dev, NULL);
    #else
        alt_irq_register(dev->mailbox_irq, dev, altera_avalon_mailbox_simple_rx_isr);
 8301aa8:	e0bfff17 	ldw	r2,-4(fp)
 8301aac:	10800b17 	ldw	r2,44(r2)
 8301ab0:	01820c34 	movhi	r6,2096
 8301ab4:	31860804 	addi	r6,r6,6176
 8301ab8:	e17fff17 	ldw	r5,-4(fp)
 8301abc:	1009883a 	mov	r4,r2
 8301ac0:	83007780 	call	8300778 <alt_irq_register>
    #endif
        /* Enable Receiver interrupt to listen mode */
        data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) |
 8301ac4:	e0bfff17 	ldw	r2,-4(fp)
 8301ac8:	10800a17 	ldw	r2,40(r2)
 8301acc:	10800304 	addi	r2,r2,12
 8301ad0:	10800037 	ldwio	r2,0(r2)
 8301ad4:	10800054 	ori	r2,r2,1
 8301ad8:	e0bffe15 	stw	r2,-8(fp)
  	             (ALTERA_AVALON_MAILBOX_SIMPLE_INTR_PEN_MSK);
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
 8301adc:	e0bfff17 	ldw	r2,-4(fp)
 8301ae0:	10800a17 	ldw	r2,40(r2)
 8301ae4:	10800304 	addi	r2,r2,12
 8301ae8:	1007883a 	mov	r3,r2
 8301aec:	e0bffe17 	ldw	r2,-8(fp)
 8301af0:	18800035 	stwio	r2,0(r3)
    }
    return dev;
 8301af4:	e0bfff17 	ldw	r2,-4(fp)
}
 8301af8:	e037883a 	mov	sp,fp
 8301afc:	dfc00117 	ldw	ra,4(sp)
 8301b00:	df000017 	ldw	fp,0(sp)
 8301b04:	dec00204 	addi	sp,sp,8
 8301b08:	f800283a 	ret

08301b0c <altera_avalon_mailbox_close>:
/*
 * altera_avalon_mailbox_close
 * Disable mailbox interrupt and irq
 */
void altera_avalon_mailbox_close (altera_avalon_mailbox_dev *dev)
{
 8301b0c:	defffc04 	addi	sp,sp,-16
 8301b10:	dfc00315 	stw	ra,12(sp)
 8301b14:	df000215 	stw	fp,8(sp)
 8301b18:	df000204 	addi	fp,sp,8
 8301b1c:	e13ffe15 	stw	r4,-8(fp)
    alt_u32 data;
    if ((dev != NULL) && (dev->mailbox_irq != ALT_IRQ_NOT_CONNECTED))
 8301b20:	e0bffe17 	ldw	r2,-8(fp)
 8301b24:	10003526 	beq	r2,zero,8301bfc <altera_avalon_mailbox_close+0xf0>
 8301b28:	e0bffe17 	ldw	r2,-8(fp)
 8301b2c:	10800b17 	ldw	r2,44(r2)
 8301b30:	10bfffe0 	cmpeqi	r2,r2,-1
 8301b34:	1000311e 	bne	r2,zero,8301bfc <altera_avalon_mailbox_close+0xf0>
    {
        /* Mask interrupt */
        if (dev->mbox_type == MBOX_TX)
 8301b38:	e0bffe17 	ldw	r2,-8(fp)
 8301b3c:	10800f17 	ldw	r2,60(r2)
 8301b40:	10000e1e 	bne	r2,zero,8301b7c <altera_avalon_mailbox_close+0x70>
        {
            data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) &
 8301b44:	e0bffe17 	ldw	r2,-8(fp)
 8301b48:	10800a17 	ldw	r2,40(r2)
 8301b4c:	10800304 	addi	r2,r2,12
 8301b50:	10800037 	ldwio	r2,0(r2)
 8301b54:	1007883a 	mov	r3,r2
 8301b58:	00bfff44 	movi	r2,-3
 8301b5c:	1884703a 	and	r2,r3,r2
 8301b60:	e0bfff15 	stw	r2,-4(fp)
                       (~ALTERA_AVALON_MAILBOX_SIMPLE_INTR_SPACE_MSK);
            IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
 8301b64:	e0bffe17 	ldw	r2,-8(fp)
 8301b68:	10800a17 	ldw	r2,40(r2)
 8301b6c:	10800304 	addi	r2,r2,12
 8301b70:	1007883a 	mov	r3,r2
 8301b74:	e0bfff17 	ldw	r2,-4(fp)
 8301b78:	18800035 	stwio	r2,0(r3)
        }
        if (dev->mbox_type == MBOX_RX)
 8301b7c:	e0bffe17 	ldw	r2,-8(fp)
 8301b80:	10800f17 	ldw	r2,60(r2)
 8301b84:	10800058 	cmpnei	r2,r2,1
 8301b88:	10000e1e 	bne	r2,zero,8301bc4 <altera_avalon_mailbox_close+0xb8>
        {
            data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) &
 8301b8c:	e0bffe17 	ldw	r2,-8(fp)
 8301b90:	10800a17 	ldw	r2,40(r2)
 8301b94:	10800304 	addi	r2,r2,12
 8301b98:	10800037 	ldwio	r2,0(r2)
 8301b9c:	1007883a 	mov	r3,r2
 8301ba0:	00bfff84 	movi	r2,-2
 8301ba4:	1884703a 	and	r2,r3,r2
 8301ba8:	e0bfff15 	stw	r2,-4(fp)
                       (~ALTERA_AVALON_MAILBOX_SIMPLE_INTR_PEN_MSK);
            IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
 8301bac:	e0bffe17 	ldw	r2,-8(fp)
 8301bb0:	10800a17 	ldw	r2,40(r2)
 8301bb4:	10800304 	addi	r2,r2,12
 8301bb8:	1007883a 	mov	r3,r2
 8301bbc:	e0bfff17 	ldw	r2,-4(fp)
 8301bc0:	18800035 	stwio	r2,0(r3)
        }
  
        /* De-register mailbox irq) */
        if (dev->mailbox_irq != ALT_IRQ_NOT_CONNECTED)
 8301bc4:	e0bffe17 	ldw	r2,-8(fp)
 8301bc8:	10800b17 	ldw	r2,44(r2)
 8301bcc:	10bfffe0 	cmpeqi	r2,r2,-1
 8301bd0:	1000061e 	bne	r2,zero,8301bec <altera_avalon_mailbox_close+0xe0>
        {
        #ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
            alt_ic_isr_register(dev->mailbox_intr_ctrl_id, dev->mailbox_irq, NULL,
                              dev, NULL);
        #else
            alt_irq_register(dev->mailbox_irq, dev, NULL);
 8301bd4:	e0bffe17 	ldw	r2,-8(fp)
 8301bd8:	10800b17 	ldw	r2,44(r2)
 8301bdc:	000d883a 	mov	r6,zero
 8301be0:	e17ffe17 	ldw	r5,-8(fp)
 8301be4:	1009883a 	mov	r4,r2
 8301be8:	83007780 	call	8300778 <alt_irq_register>
        #endif
        }
        /* De-registering callback to mailbox */
        dev->tx_cb  = NULL;
 8301bec:	e0bffe17 	ldw	r2,-8(fp)
 8301bf0:	10000d15 	stw	zero,52(r2)
        dev->rx_cb  = NULL;
 8301bf4:	e0bffe17 	ldw	r2,-8(fp)
 8301bf8:	10000e15 	stw	zero,56(r2)
    }
}
 8301bfc:	0001883a 	nop
 8301c00:	e037883a 	mov	sp,fp
 8301c04:	dfc00117 	ldw	ra,4(sp)
 8301c08:	df000017 	ldw	fp,0(sp)
 8301c0c:	dec00204 	addi	sp,sp,8
 8301c10:	f800283a 	ret

08301c14 <altera_avalon_mailbox_status>:
 *   Return 0 when mailbox is empty or no pending message
 *   Return 1 when mailbox space is full or there is a message pending
 */

alt_u32 altera_avalon_mailbox_status (altera_avalon_mailbox_dev *dev)
{
 8301c14:	defffd04 	addi	sp,sp,-12
 8301c18:	df000215 	stw	fp,8(sp)
 8301c1c:	df000204 	addi	fp,sp,8
 8301c20:	e13ffe15 	stw	r4,-8(fp)
    alt_u32 mailbox_sts = 0;
 8301c24:	e03fff15 	stw	zero,-4(fp)

    mailbox_sts = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_STS_OFST) & ALTERA_AVALON_MAILBOX_SIMPLE_STS_MSK);
 8301c28:	e0bffe17 	ldw	r2,-8(fp)
 8301c2c:	10800a17 	ldw	r2,40(r2)
 8301c30:	10800204 	addi	r2,r2,8
 8301c34:	10800037 	ldwio	r2,0(r2)
 8301c38:	108000cc 	andi	r2,r2,3
 8301c3c:	e0bfff15 	stw	r2,-4(fp)

    if (dev->mbox_type == MBOX_TX)
 8301c40:	e0bffe17 	ldw	r2,-8(fp)
 8301c44:	10800f17 	ldw	r2,60(r2)
 8301c48:	1000041e 	bne	r2,zero,8301c5c <altera_avalon_mailbox_status+0x48>
        mailbox_sts = (mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK) >> 1;
 8301c4c:	e0bfff17 	ldw	r2,-4(fp)
 8301c50:	1004d07a 	srli	r2,r2,1
 8301c54:	1080004c 	andi	r2,r2,1
 8301c58:	e0bfff15 	stw	r2,-4(fp)

    if (dev->mbox_type == MBOX_RX)
 8301c5c:	e0bffe17 	ldw	r2,-8(fp)
 8301c60:	10800f17 	ldw	r2,60(r2)
 8301c64:	10800058 	cmpnei	r2,r2,1
 8301c68:	1000031e 	bne	r2,zero,8301c78 <altera_avalon_mailbox_status+0x64>
        mailbox_sts = mailbox_sts & ALTERA_AVALON_MAILBOX_SIMPLE_STS_PENDING_MSK;
 8301c6c:	e0bfff17 	ldw	r2,-4(fp)
 8301c70:	1080004c 	andi	r2,r2,1
 8301c74:	e0bfff15 	stw	r2,-4(fp)

    return mailbox_sts;
 8301c78:	e0bfff17 	ldw	r2,-4(fp)
}
 8301c7c:	e037883a 	mov	sp,fp
 8301c80:	df000017 	ldw	fp,0(sp)
 8301c84:	dec00104 	addi	sp,sp,4
 8301c88:	f800283a 	ret

08301c8c <altera_avalon_mailbox_send>:
 * For polling mode, '0' timeout value for infinite polling
 * otherwise timeout when expired
 */
int altera_avalon_mailbox_send
(altera_avalon_mailbox_dev *dev, void *message, int timeout, EventType event)
{
 8301c8c:	defff704 	addi	sp,sp,-36
 8301c90:	dfc00815 	stw	ra,32(sp)
 8301c94:	df000715 	stw	fp,28(sp)
 8301c98:	df000704 	addi	fp,sp,28
 8301c9c:	e13ffc15 	stw	r4,-16(fp)
 8301ca0:	e17ffb15 	stw	r5,-20(fp)
 8301ca4:	e1bffa15 	stw	r6,-24(fp)
 8301ca8:	e1fff915 	stw	r7,-28(fp)
    int status = 0;
 8301cac:	e03fff15 	stw	zero,-4(fp)
     * Obtain the "write_lock"semaphore to ensures 
     * that writing to the device is thread-safe in multi-thread enviroment
     */
    ALT_SEM_PEND (dev->write_lock, 0);

    if (dev->lock || (IORD_ALTERA_AVALON_MAILBOX_STS(dev->base)
 8301cb0:	e0bffc17 	ldw	r2,-16(fp)
 8301cb4:	10801103 	ldbu	r2,68(r2)
 8301cb8:	10803fcc 	andi	r2,r2,255
 8301cbc:	1000061e 	bne	r2,zero,8301cd8 <altera_avalon_mailbox_send+0x4c>
 8301cc0:	e0bffc17 	ldw	r2,-16(fp)
 8301cc4:	10800a17 	ldw	r2,40(r2)
 8301cc8:	10800204 	addi	r2,r2,8
 8301ccc:	10800037 	ldwio	r2,0(r2)
    		          & ALTERA_AVALON_MAILBOX_SIMPLE_STS_FULL_MSK))
 8301cd0:	1080008c 	andi	r2,r2,2
    if (dev->lock || (IORD_ALTERA_AVALON_MAILBOX_STS(dev->base)
 8301cd4:	10000226 	beq	r2,zero,8301ce0 <altera_avalon_mailbox_send+0x54>
    {
    	/* dev is lock or no free space to send */
    	return -1;
 8301cd8:	00bfffc4 	movi	r2,-1
 8301cdc:	00003a06 	br	8301dc8 <altera_avalon_mailbox_send+0x13c>
    }
    else
    {
        dev->mbox_msg = message;
 8301ce0:	e0bffc17 	ldw	r2,-16(fp)
 8301ce4:	e0fffb17 	ldw	r3,-20(fp)
 8301ce8:	10c01015 	stw	r3,64(r2)
        dev->lock = 1;
 8301cec:	e0bffc17 	ldw	r2,-16(fp)
 8301cf0:	00c00044 	movi	r3,1
 8301cf4:	10c01105 	stb	r3,68(r2)
     */
    ALT_SEM_POST (dev->write_lock);



    if ((dev->mailbox_irq == ALT_IRQ_NOT_CONNECTED) || (event==POLL))
 8301cf8:	e0bffc17 	ldw	r2,-16(fp)
 8301cfc:	10800b17 	ldw	r2,44(r2)
 8301d00:	10bfffe0 	cmpeqi	r2,r2,-1
 8301d04:	1000031e 	bne	r2,zero,8301d14 <altera_avalon_mailbox_send+0x88>
 8301d08:	e0bff917 	ldw	r2,-28(fp)
 8301d0c:	10800058 	cmpnei	r2,r2,1
 8301d10:	1000201e 	bne	r2,zero,8301d94 <altera_avalon_mailbox_send+0x108>
    {
        /* Polling mode */
        if (timeout ==0)
 8301d14:	e0bffa17 	ldw	r2,-24(fp)
 8301d18:	1000061e 	bne	r2,zero,8301d34 <altera_avalon_mailbox_send+0xa8>
        {
            do
            {
                mbox_status = altera_avalon_mailbox_status(dev);
 8301d1c:	e13ffc17 	ldw	r4,-16(fp)
 8301d20:	8301c140 	call	8301c14 <altera_avalon_mailbox_status>
 8301d24:	e0bffd15 	stw	r2,-12(fp)
            } while (mbox_status);
 8301d28:	e0bffd17 	ldw	r2,-12(fp)
 8301d2c:	103ffb1e 	bne	r2,zero,8301d1c <altera_avalon_mailbox_send+0x90>
 8301d30:	00000e06 	br	8301d6c <altera_avalon_mailbox_send+0xe0>
        } else
        {
            do
            {
                mbox_status = altera_avalon_mailbox_status(dev);
 8301d34:	e13ffc17 	ldw	r4,-16(fp)
 8301d38:	8301c140 	call	8301c14 <altera_avalon_mailbox_status>
 8301d3c:	e0bffd15 	stw	r2,-12(fp)
                timeout--;
 8301d40:	e0bffa17 	ldw	r2,-24(fp)
 8301d44:	10bfffc4 	addi	r2,r2,-1
 8301d48:	e0bffa15 	stw	r2,-24(fp)
            } while (mbox_status && (timeout != 0));
 8301d4c:	e0bffd17 	ldw	r2,-12(fp)
 8301d50:	10000226 	beq	r2,zero,8301d5c <altera_avalon_mailbox_send+0xd0>
 8301d54:	e0bffa17 	ldw	r2,-24(fp)
 8301d58:	103ff61e 	bne	r2,zero,8301d34 <altera_avalon_mailbox_send+0xa8>
            if (timeout == 0)
 8301d5c:	e0bffa17 	ldw	r2,-24(fp)
 8301d60:	1000021e 	bne	r2,zero,8301d6c <altera_avalon_mailbox_send+0xe0>
            {    /* Timeout occur or fail sending */
                return -ETIME;
 8301d64:	00bff084 	movi	r2,-62
 8301d68:	00001706 	br	8301dc8 <altera_avalon_mailbox_send+0x13c>
            }
        }
        status = altera_avalon_mailbox_post (dev, message);
 8301d6c:	e17ffb17 	ldw	r5,-20(fp)
 8301d70:	e13ffc17 	ldw	r4,-16(fp)
 8301d74:	83016680 	call	8301668 <altera_avalon_mailbox_post>
 8301d78:	e0bfff15 	stw	r2,-4(fp)
        /* Clear mailbox message to NULL after message being posted */
        dev->mbox_msg = NULL;
 8301d7c:	e0bffc17 	ldw	r2,-16(fp)
 8301d80:	10001015 	stw	zero,64(r2)
        /* Release lock when message posted */
        dev->lock =0;
 8301d84:	e0bffc17 	ldw	r2,-16(fp)
 8301d88:	10001105 	stb	zero,68(r2)
        return status;
 8301d8c:	e0bfff17 	ldw	r2,-4(fp)
 8301d90:	00000d06 	br	8301dc8 <altera_avalon_mailbox_send+0x13c>
    } else
    {
        /* Enable Sender interrupt */
        data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST) |
 8301d94:	e0bffc17 	ldw	r2,-16(fp)
 8301d98:	10800a17 	ldw	r2,40(r2)
 8301d9c:	10800304 	addi	r2,r2,12
 8301da0:	10800037 	ldwio	r2,0(r2)
 8301da4:	10800094 	ori	r2,r2,2
 8301da8:	e0bffe15 	stw	r2,-8(fp)
                   (ALTERA_AVALON_MAILBOX_SIMPLE_INTR_SPACE_MSK);
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
 8301dac:	e0bffc17 	ldw	r2,-16(fp)
 8301db0:	10800a17 	ldw	r2,40(r2)
 8301db4:	10800304 	addi	r2,r2,12
 8301db8:	1007883a 	mov	r3,r2
 8301dbc:	e0bffe17 	ldw	r2,-8(fp)
 8301dc0:	18800035 	stwio	r2,0(r3)
    }
  return 0;
 8301dc4:	0005883a 	mov	r2,zero
}
 8301dc8:	e037883a 	mov	sp,fp
 8301dcc:	dfc00117 	ldw	ra,4(sp)
 8301dd0:	df000017 	ldw	fp,0(sp)
 8301dd4:	dec00204 	addi	sp,sp,8
 8301dd8:	f800283a 	ret

08301ddc <altera_avalon_mailbox_retrieve_poll>:
 * If a message is available in the mailbox return it otherwise return NULL
 * This function is blocking
 *
 */
int altera_avalon_mailbox_retrieve_poll (altera_avalon_mailbox_dev *dev, alt_u32 *message, alt_u32 timeout)
{
 8301ddc:	defff904 	addi	sp,sp,-28
 8301de0:	dfc00615 	stw	ra,24(sp)
 8301de4:	df000515 	stw	fp,20(sp)
 8301de8:	df000504 	addi	fp,sp,20
 8301dec:	e13ffd15 	stw	r4,-12(fp)
 8301df0:	e17ffc15 	stw	r5,-16(fp)
 8301df4:	e1bffb15 	stw	r6,-20(fp)
    alt_u32 status = 0;
 8301df8:	e03fff15 	stw	zero,-4(fp)
    alt_u32 data;

    if (dev != NULL && message != NULL)
 8301dfc:	e0bffd17 	ldw	r2,-12(fp)
 8301e00:	10003a26 	beq	r2,zero,8301eec <altera_avalon_mailbox_retrieve_poll+0x110>
 8301e04:	e0bffc17 	ldw	r2,-16(fp)
 8301e08:	10003826 	beq	r2,zero,8301eec <altera_avalon_mailbox_retrieve_poll+0x110>
    {
        /* Mask receiver mailbox interrupt when in polling mode */
        data = IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST);
 8301e0c:	e0bffd17 	ldw	r2,-12(fp)
 8301e10:	10800a17 	ldw	r2,40(r2)
 8301e14:	10800304 	addi	r2,r2,12
 8301e18:	10800037 	ldwio	r2,0(r2)
 8301e1c:	e0bffe15 	stw	r2,-8(fp)
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST,
 8301e20:	e0bffd17 	ldw	r2,-12(fp)
 8301e24:	10800a17 	ldw	r2,40(r2)
 8301e28:	10800304 	addi	r2,r2,12
 8301e2c:	1009883a 	mov	r4,r2
 8301e30:	e0fffe17 	ldw	r3,-8(fp)
 8301e34:	00bfff84 	movi	r2,-2
 8301e38:	1884703a 	and	r2,r3,r2
 8301e3c:	20800035 	stwio	r2,0(r4)
            (data & (~ALTERA_AVALON_MAILBOX_SIMPLE_INTR_PEN_MSK)));


        /* If timeout is '0', poll till message availabe in mailbox */
        if (timeout == 0)
 8301e40:	e0bffb17 	ldw	r2,-20(fp)
 8301e44:	1000061e 	bne	r2,zero,8301e60 <altera_avalon_mailbox_retrieve_poll+0x84>
        {
            do
            {
                status = altera_avalon_mailbox_status (dev);
 8301e48:	e13ffd17 	ldw	r4,-12(fp)
 8301e4c:	8301c140 	call	8301c14 <altera_avalon_mailbox_status>
 8301e50:	e0bfff15 	stw	r2,-4(fp)
            } while (status == 0);
 8301e54:	e0bfff17 	ldw	r2,-4(fp)
 8301e58:	103ffb26 	beq	r2,zero,8301e48 <altera_avalon_mailbox_retrieve_poll+0x6c>
 8301e5c:	00000a06 	br	8301e88 <altera_avalon_mailbox_retrieve_poll+0xac>
        } else
        {
            do
            {
                 status = altera_avalon_mailbox_status (dev);
 8301e60:	e13ffd17 	ldw	r4,-12(fp)
 8301e64:	8301c140 	call	8301c14 <altera_avalon_mailbox_status>
 8301e68:	e0bfff15 	stw	r2,-4(fp)
                 timeout-- ;
 8301e6c:	e0bffb17 	ldw	r2,-20(fp)
 8301e70:	10bfffc4 	addi	r2,r2,-1
 8301e74:	e0bffb15 	stw	r2,-20(fp)
            } while ((status == 0) && timeout);
 8301e78:	e0bfff17 	ldw	r2,-4(fp)
 8301e7c:	1000021e 	bne	r2,zero,8301e88 <altera_avalon_mailbox_retrieve_poll+0xac>
 8301e80:	e0bffb17 	ldw	r2,-20(fp)
 8301e84:	103ff61e 	bne	r2,zero,8301e60 <altera_avalon_mailbox_retrieve_poll+0x84>
        }

        /* if timeout, status remain 0 */
        if (status)
 8301e88:	e0bfff17 	ldw	r2,-4(fp)
 8301e8c:	10000d26 	beq	r2,zero,8301ec4 <altera_avalon_mailbox_retrieve_poll+0xe8>
        {
            message[1] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_PTR_OFST));
 8301e90:	e0bffd17 	ldw	r2,-12(fp)
 8301e94:	10800a17 	ldw	r2,40(r2)
 8301e98:	10800104 	addi	r2,r2,4
 8301e9c:	10c00037 	ldwio	r3,0(r2)
 8301ea0:	e0bffc17 	ldw	r2,-16(fp)
 8301ea4:	10800104 	addi	r2,r2,4
 8301ea8:	10c00015 	stw	r3,0(r2)
            message[0] = (IORD(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_CMD_OFST));
 8301eac:	e0bffd17 	ldw	r2,-12(fp)
 8301eb0:	10800a17 	ldw	r2,40(r2)
 8301eb4:	10800037 	ldwio	r2,0(r2)
 8301eb8:	1007883a 	mov	r3,r2
 8301ebc:	e0bffc17 	ldw	r2,-16(fp)
 8301ec0:	10c00015 	stw	r3,0(r2)
        }
        /* Restore original state of interrupt mask */
        IOWR(dev->base, ALTERA_AVALON_MAILBOX_SIMPLE_INTR_OFST, data);
 8301ec4:	e0bffd17 	ldw	r2,-12(fp)
 8301ec8:	10800a17 	ldw	r2,40(r2)
 8301ecc:	10800304 	addi	r2,r2,12
 8301ed0:	1007883a 	mov	r3,r2
 8301ed4:	e0bffe17 	ldw	r2,-8(fp)
 8301ed8:	18800035 	stwio	r2,0(r3)

        /* Return success on complete retrieve message
         * otherwise timeout and exit with error
         */
        if (status)
 8301edc:	e0bfff17 	ldw	r2,-4(fp)
 8301ee0:	10000226 	beq	r2,zero,8301eec <altera_avalon_mailbox_retrieve_poll+0x110>
          return 0;
 8301ee4:	0005883a 	mov	r2,zero
 8301ee8:	00000606 	br	8301f04 <altera_avalon_mailbox_retrieve_poll+0x128>
      }
      /* Invalid Null dev and message */
      message[1] = 0;
 8301eec:	e0bffc17 	ldw	r2,-16(fp)
 8301ef0:	10800104 	addi	r2,r2,4
 8301ef4:	10000015 	stw	zero,0(r2)
      message[0] = 0;
 8301ef8:	e0bffc17 	ldw	r2,-16(fp)
 8301efc:	10000015 	stw	zero,0(r2)
      return -EINVAL;
 8301f00:	00bffa84 	movi	r2,-22
}
 8301f04:	e037883a 	mov	sp,fp
 8301f08:	dfc00117 	ldw	ra,4(sp)
 8301f0c:	df000017 	ldw	fp,0(sp)
 8301f10:	dec00204 	addi	sp,sp,8
 8301f14:	f800283a 	ret

08301f18 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 8301f18:	defff904 	addi	sp,sp,-28
 8301f1c:	dfc00615 	stw	ra,24(sp)
 8301f20:	df000515 	stw	fp,20(sp)
 8301f24:	df000504 	addi	fp,sp,20
 8301f28:	e13ffc15 	stw	r4,-16(fp)
 8301f2c:	e17ffb15 	stw	r5,-20(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 8301f30:	0007883a 	mov	r3,zero
 8301f34:	e0bffc17 	ldw	r2,-16(fp)
 8301f38:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 8301f3c:	e0bffc17 	ldw	r2,-16(fp)
 8301f40:	10800104 	addi	r2,r2,4
 8301f44:	10800037 	ldwio	r2,0(r2)
  NIOS2_READ_STATUS (context);
 8301f48:	0005303a 	rdctl	r2,status
 8301f4c:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 8301f50:	e0fffd17 	ldw	r3,-12(fp)
 8301f54:	00bfff84 	movi	r2,-2
 8301f58:	1884703a 	and	r2,r3,r2
 8301f5c:	1001703a 	wrctl	status,r2
  return context;
 8301f60:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 8301f64:	e0bfff15 	stw	r2,-4(fp)
  alt_tick ();
 8301f68:	83031740 	call	8303174 <alt_tick>
 8301f6c:	e0bfff17 	ldw	r2,-4(fp)
 8301f70:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
 8301f74:	e0bffe17 	ldw	r2,-8(fp)
 8301f78:	1001703a 	wrctl	status,r2
}
 8301f7c:	0001883a 	nop
  alt_irq_enable_all(cpu_sr);
}
 8301f80:	0001883a 	nop
 8301f84:	e037883a 	mov	sp,fp
 8301f88:	dfc00117 	ldw	ra,4(sp)
 8301f8c:	df000017 	ldw	fp,0(sp)
 8301f90:	dec00204 	addi	sp,sp,8
 8301f94:	f800283a 	ret

08301f98 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 8301f98:	defff904 	addi	sp,sp,-28
 8301f9c:	dfc00615 	stw	ra,24(sp)
 8301fa0:	df000515 	stw	fp,20(sp)
 8301fa4:	df000504 	addi	fp,sp,20
 8301fa8:	e13ffe15 	stw	r4,-8(fp)
 8301fac:	e17ffd15 	stw	r5,-12(fp)
 8301fb0:	e1bffc15 	stw	r6,-16(fp)
 8301fb4:	e1fffb15 	stw	r7,-20(fp)
 8301fb8:	e0bffb17 	ldw	r2,-20(fp)
 8301fbc:	e0bfff15 	stw	r2,-4(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 8301fc0:	d0a5e917 	ldw	r2,-26716(gp)
 8301fc4:	1000031e 	bne	r2,zero,8301fd4 <alt_avalon_timer_sc_init+0x3c>
  {
    _alt_tick_rate = nticks;
 8301fc8:	e0bfff17 	ldw	r2,-4(fp)
 8301fcc:	d0a5e915 	stw	r2,-26716(gp)
    return 0;
 8301fd0:	00000106 	br	8301fd8 <alt_avalon_timer_sc_init+0x40>
  }
  else
  {
    return -1;
 8301fd4:	0001883a 	nop
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 8301fd8:	e0bffe17 	ldw	r2,-8(fp)
 8301fdc:	10800104 	addi	r2,r2,4
 8301fe0:	00c001c4 	movi	r3,7
 8301fe4:	10c00035 	stwio	r3,0(r2)
  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
 8301fe8:	01820c34 	movhi	r6,2096
 8301fec:	3187c604 	addi	r6,r6,7960
 8301ff0:	e17ffe17 	ldw	r5,-8(fp)
 8301ff4:	e13ffc17 	ldw	r4,-16(fp)
 8301ff8:	83007780 	call	8300778 <alt_irq_register>
#endif  
}
 8301ffc:	0001883a 	nop
 8302000:	e037883a 	mov	sp,fp
 8302004:	dfc00117 	ldw	ra,4(sp)
 8302008:	df000017 	ldw	fp,0(sp)
 830200c:	dec00204 	addi	sp,sp,8
 8302010:	f800283a 	ret

08302014 <alt_up_audio_open_dev>:
#include "altera_up_avalon_audio_regs.h"

///////////////////////////////////////////////////////////////////////////
// Direct functions
alt_up_audio_dev* alt_up_audio_open_dev(const char* name)
{
 8302014:	defffc04 	addi	sp,sp,-16
 8302018:	dfc00315 	stw	ra,12(sp)
 830201c:	df000215 	stw	fp,8(sp)
 8302020:	df000204 	addi	fp,sp,8
 8302024:	e13ffe15 	stw	r4,-8(fp)
  // find the device from the device list 
  // (see altera_hal/HAL/inc/priv/alt_file.h 
  // and altera_hal/HAL/src/alt_find_dev.c 
  // for details)
  alt_up_audio_dev *dev = (alt_up_audio_dev*)alt_find_dev(name, &alt_dev_list);
 8302028:	d1600504 	addi	r5,gp,-32748
 830202c:	e13ffe17 	ldw	r4,-8(fp)
 8302030:	8302be80 	call	8302be8 <alt_find_dev>
 8302034:	e0bfff15 	stw	r2,-4(fp)
  return dev;
 8302038:	e0bfff17 	ldw	r2,-4(fp)
}
 830203c:	e037883a 	mov	sp,fp
 8302040:	dfc00117 	ldw	ra,4(sp)
 8302044:	df000017 	ldw	fp,0(sp)
 8302048:	dec00204 	addi	sp,sp,8
 830204c:	f800283a 	ret

08302050 <alt_up_audio_enable_read_interrupt>:

void alt_up_audio_enable_read_interrupt(alt_up_audio_dev *audio)
{
 8302050:	defffd04 	addi	sp,sp,-12
 8302054:	df000215 	stw	fp,8(sp)
 8302058:	df000204 	addi	fp,sp,8
 830205c:	e13ffe15 	stw	r4,-8(fp)
	unsigned int ctrl_reg;
	ctrl_reg = IORD_ALT_UP_AUDIO_CONTROL(audio->base); 
 8302060:	e0bffe17 	ldw	r2,-8(fp)
 8302064:	10800a17 	ldw	r2,40(r2)
 8302068:	10800037 	ldwio	r2,0(r2)
 830206c:	e0bfff15 	stw	r2,-4(fp)
	// set RE to 1 while maintaining other bits the same
	ctrl_reg |= ALT_UP_AUDIO_CONTROL_RE_MSK;
 8302070:	e0bfff17 	ldw	r2,-4(fp)
 8302074:	10800054 	ori	r2,r2,1
 8302078:	e0bfff15 	stw	r2,-4(fp)
	IOWR_ALT_UP_AUDIO_CONTROL(audio->base, ctrl_reg);
 830207c:	e0bffe17 	ldw	r2,-8(fp)
 8302080:	10800a17 	ldw	r2,40(r2)
 8302084:	1007883a 	mov	r3,r2
 8302088:	e0bfff17 	ldw	r2,-4(fp)
 830208c:	18800035 	stwio	r2,0(r3)
}
 8302090:	0001883a 	nop
 8302094:	e037883a 	mov	sp,fp
 8302098:	df000017 	ldw	fp,0(sp)
 830209c:	dec00104 	addi	sp,sp,4
 83020a0:	f800283a 	ret

083020a4 <alt_up_audio_disable_read_interrupt>:

void alt_up_audio_disable_read_interrupt(alt_up_audio_dev *audio)
{
 83020a4:	defffd04 	addi	sp,sp,-12
 83020a8:	df000215 	stw	fp,8(sp)
 83020ac:	df000204 	addi	fp,sp,8
 83020b0:	e13ffe15 	stw	r4,-8(fp)
	unsigned int ctrl_reg;
	ctrl_reg = IORD_ALT_UP_AUDIO_CONTROL(audio->base); 
 83020b4:	e0bffe17 	ldw	r2,-8(fp)
 83020b8:	10800a17 	ldw	r2,40(r2)
 83020bc:	10800037 	ldwio	r2,0(r2)
 83020c0:	e0bfff15 	stw	r2,-4(fp)
	// set RE to 0 while maintaining other bits the same
	ctrl_reg &= ~ALT_UP_AUDIO_CONTROL_RE_MSK;
 83020c4:	e0ffff17 	ldw	r3,-4(fp)
 83020c8:	00bfff84 	movi	r2,-2
 83020cc:	1884703a 	and	r2,r3,r2
 83020d0:	e0bfff15 	stw	r2,-4(fp)
	IOWR_ALT_UP_AUDIO_CONTROL(audio->base, ctrl_reg);
 83020d4:	e0bffe17 	ldw	r2,-8(fp)
 83020d8:	10800a17 	ldw	r2,40(r2)
 83020dc:	1007883a 	mov	r3,r2
 83020e0:	e0bfff17 	ldw	r2,-4(fp)
 83020e4:	18800035 	stwio	r2,0(r3)
}
 83020e8:	0001883a 	nop
 83020ec:	e037883a 	mov	sp,fp
 83020f0:	df000017 	ldw	fp,0(sp)
 83020f4:	dec00104 	addi	sp,sp,4
 83020f8:	f800283a 	ret

083020fc <alt_up_audio_enable_write_interrupt>:

void alt_up_audio_enable_write_interrupt(alt_up_audio_dev *audio)
{
 83020fc:	defffd04 	addi	sp,sp,-12
 8302100:	df000215 	stw	fp,8(sp)
 8302104:	df000204 	addi	fp,sp,8
 8302108:	e13ffe15 	stw	r4,-8(fp)
	unsigned int ctrl_reg;
	ctrl_reg = IORD_ALT_UP_AUDIO_CONTROL(audio->base); 
 830210c:	e0bffe17 	ldw	r2,-8(fp)
 8302110:	10800a17 	ldw	r2,40(r2)
 8302114:	10800037 	ldwio	r2,0(r2)
 8302118:	e0bfff15 	stw	r2,-4(fp)
	// set WE to 1 while maintaining other bits the same
	ctrl_reg |= ALT_UP_AUDIO_CONTROL_WE_MSK;
 830211c:	e0bfff17 	ldw	r2,-4(fp)
 8302120:	10800094 	ori	r2,r2,2
 8302124:	e0bfff15 	stw	r2,-4(fp)
	IOWR_ALT_UP_AUDIO_CONTROL(audio->base, ctrl_reg);
 8302128:	e0bffe17 	ldw	r2,-8(fp)
 830212c:	10800a17 	ldw	r2,40(r2)
 8302130:	1007883a 	mov	r3,r2
 8302134:	e0bfff17 	ldw	r2,-4(fp)
 8302138:	18800035 	stwio	r2,0(r3)
}
 830213c:	0001883a 	nop
 8302140:	e037883a 	mov	sp,fp
 8302144:	df000017 	ldw	fp,0(sp)
 8302148:	dec00104 	addi	sp,sp,4
 830214c:	f800283a 	ret

08302150 <alt_up_audio_disable_write_interrupt>:

void alt_up_audio_disable_write_interrupt(alt_up_audio_dev *audio)
{
 8302150:	defffd04 	addi	sp,sp,-12
 8302154:	df000215 	stw	fp,8(sp)
 8302158:	df000204 	addi	fp,sp,8
 830215c:	e13ffe15 	stw	r4,-8(fp)
	unsigned int ctrl_reg;
	ctrl_reg = IORD_ALT_UP_AUDIO_CONTROL(audio->base); 
 8302160:	e0bffe17 	ldw	r2,-8(fp)
 8302164:	10800a17 	ldw	r2,40(r2)
 8302168:	10800037 	ldwio	r2,0(r2)
 830216c:	e0bfff15 	stw	r2,-4(fp)
	// set WE to 0 while maintaining other bits the same
	ctrl_reg &= ~ALT_UP_AUDIO_CONTROL_WE_MSK;
 8302170:	e0ffff17 	ldw	r3,-4(fp)
 8302174:	00bfff44 	movi	r2,-3
 8302178:	1884703a 	and	r2,r3,r2
 830217c:	e0bfff15 	stw	r2,-4(fp)
	IOWR_ALT_UP_AUDIO_CONTROL(audio->base, ctrl_reg);
 8302180:	e0bffe17 	ldw	r2,-8(fp)
 8302184:	10800a17 	ldw	r2,40(r2)
 8302188:	1007883a 	mov	r3,r2
 830218c:	e0bfff17 	ldw	r2,-4(fp)
 8302190:	18800035 	stwio	r2,0(r3)
}
 8302194:	0001883a 	nop
 8302198:	e037883a 	mov	sp,fp
 830219c:	df000017 	ldw	fp,0(sp)
 83021a0:	dec00104 	addi	sp,sp,4
 83021a4:	f800283a 	ret

083021a8 <alt_up_audio_read_interrupt_pending>:

int alt_up_audio_read_interrupt_pending(alt_up_audio_dev *audio)
{
 83021a8:	defffd04 	addi	sp,sp,-12
 83021ac:	df000215 	stw	fp,8(sp)
 83021b0:	df000204 	addi	fp,sp,8
 83021b4:	e13ffe15 	stw	r4,-8(fp)
	unsigned int ctrl_reg;
	ctrl_reg = IORD_ALT_UP_AUDIO_CONTROL(audio->base); 
 83021b8:	e0bffe17 	ldw	r2,-8(fp)
 83021bc:	10800a17 	ldw	r2,40(r2)
 83021c0:	10800037 	ldwio	r2,0(r2)
 83021c4:	e0bfff15 	stw	r2,-4(fp)
	// return 1 if RI is set to 1
	return ( (ctrl_reg & ALT_UP_AUDIO_CONTROL_RI_MSK) ? 1 : 0 );
 83021c8:	e0bfff17 	ldw	r2,-4(fp)
 83021cc:	1004d23a 	srli	r2,r2,8
 83021d0:	1080004c 	andi	r2,r2,1
}
 83021d4:	e037883a 	mov	sp,fp
 83021d8:	df000017 	ldw	fp,0(sp)
 83021dc:	dec00104 	addi	sp,sp,4
 83021e0:	f800283a 	ret

083021e4 <alt_up_audio_write_interrupt_pending>:

int alt_up_audio_write_interrupt_pending(alt_up_audio_dev *audio)
{
 83021e4:	defffd04 	addi	sp,sp,-12
 83021e8:	df000215 	stw	fp,8(sp)
 83021ec:	df000204 	addi	fp,sp,8
 83021f0:	e13ffe15 	stw	r4,-8(fp)
	unsigned int ctrl_reg;
	ctrl_reg = IORD_ALT_UP_AUDIO_CONTROL(audio->base); 
 83021f4:	e0bffe17 	ldw	r2,-8(fp)
 83021f8:	10800a17 	ldw	r2,40(r2)
 83021fc:	10800037 	ldwio	r2,0(r2)
 8302200:	e0bfff15 	stw	r2,-4(fp)
	// return the WI value
	return ( (ctrl_reg & ALT_UP_AUDIO_CONTROL_WI_MSK) ? 1 : 0 );
 8302204:	e0bfff17 	ldw	r2,-4(fp)
 8302208:	1004d27a 	srli	r2,r2,9
 830220c:	1080004c 	andi	r2,r2,1
}
 8302210:	e037883a 	mov	sp,fp
 8302214:	df000017 	ldw	fp,0(sp)
 8302218:	dec00104 	addi	sp,sp,4
 830221c:	f800283a 	ret

08302220 <alt_up_audio_reset_audio_core>:

void alt_up_audio_reset_audio_core(alt_up_audio_dev *audio)
{
 8302220:	defffd04 	addi	sp,sp,-12
 8302224:	df000215 	stw	fp,8(sp)
 8302228:	df000204 	addi	fp,sp,8
 830222c:	e13ffe15 	stw	r4,-8(fp)
	unsigned int ctrl_reg;
	ctrl_reg = IORD_ALT_UP_AUDIO_CONTROL(audio->base); 
 8302230:	e0bffe17 	ldw	r2,-8(fp)
 8302234:	10800a17 	ldw	r2,40(r2)
 8302238:	10800037 	ldwio	r2,0(r2)
 830223c:	e0bfff15 	stw	r2,-4(fp)
	// set CR and CW to 1 while maintaining other bits the same
	ctrl_reg |= ALT_UP_AUDIO_CONTROL_CR_MSK;
 8302240:	e0bfff17 	ldw	r2,-4(fp)
 8302244:	10800114 	ori	r2,r2,4
 8302248:	e0bfff15 	stw	r2,-4(fp)
	ctrl_reg |= ALT_UP_AUDIO_CONTROL_CW_MSK;
 830224c:	e0bfff17 	ldw	r2,-4(fp)
 8302250:	10800214 	ori	r2,r2,8
 8302254:	e0bfff15 	stw	r2,-4(fp)
	IOWR_ALT_UP_AUDIO_CONTROL(audio->base, ctrl_reg);
 8302258:	e0bffe17 	ldw	r2,-8(fp)
 830225c:	10800a17 	ldw	r2,40(r2)
 8302260:	1007883a 	mov	r3,r2
 8302264:	e0bfff17 	ldw	r2,-4(fp)
 8302268:	18800035 	stwio	r2,0(r3)
	// set CR and CW to 0 while maintaining other bits the same
	ctrl_reg &= ~ALT_UP_AUDIO_CONTROL_CR_MSK;
 830226c:	e0ffff17 	ldw	r3,-4(fp)
 8302270:	00bffec4 	movi	r2,-5
 8302274:	1884703a 	and	r2,r3,r2
 8302278:	e0bfff15 	stw	r2,-4(fp)
	ctrl_reg &= ~ALT_UP_AUDIO_CONTROL_CW_MSK;
 830227c:	e0ffff17 	ldw	r3,-4(fp)
 8302280:	00bffdc4 	movi	r2,-9
 8302284:	1884703a 	and	r2,r3,r2
 8302288:	e0bfff15 	stw	r2,-4(fp)
	IOWR_ALT_UP_AUDIO_CONTROL(audio->base, ctrl_reg);
 830228c:	e0bffe17 	ldw	r2,-8(fp)
 8302290:	10800a17 	ldw	r2,40(r2)
 8302294:	1007883a 	mov	r3,r2
 8302298:	e0bfff17 	ldw	r2,-4(fp)
 830229c:	18800035 	stwio	r2,0(r3)
}
 83022a0:	0001883a 	nop
 83022a4:	e037883a 	mov	sp,fp
 83022a8:	df000017 	ldw	fp,0(sp)
 83022ac:	dec00104 	addi	sp,sp,4
 83022b0:	f800283a 	ret

083022b4 <alt_up_audio_read_fifo_avail>:

/* Provides number of words of data available in the incoming FIFO: RALC or RARC */
unsigned int alt_up_audio_read_fifo_avail(alt_up_audio_dev *audio, int channel)
{
 83022b4:	defffc04 	addi	sp,sp,-16
 83022b8:	df000315 	stw	fp,12(sp)
 83022bc:	df000304 	addi	fp,sp,12
 83022c0:	e13ffe15 	stw	r4,-8(fp)
 83022c4:	e17ffd15 	stw	r5,-12(fp)
	unsigned int fifospace;
	// read the whole fifospace register
	fifospace = IORD_ALT_UP_AUDIO_FIFOSPACE(audio->base);
 83022c8:	e0bffe17 	ldw	r2,-8(fp)
 83022cc:	10800a17 	ldw	r2,40(r2)
 83022d0:	10800104 	addi	r2,r2,4
 83022d4:	10800037 	ldwio	r2,0(r2)
 83022d8:	e0bfff15 	stw	r2,-4(fp)
	// extract the part for proper Channel Read Space
	fifospace = (channel == ALT_UP_AUDIO_LEFT) ? 
		(fifospace & ALT_UP_AUDIO_FIFOSPACE_RALC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_RALC_OFST :
 83022dc:	e0bffd17 	ldw	r2,-12(fp)
 83022e0:	1000041e 	bne	r2,zero,83022f4 <alt_up_audio_read_fifo_avail+0x40>
 83022e4:	e0bfff17 	ldw	r2,-4(fp)
 83022e8:	1004d23a 	srli	r2,r2,8
 83022ec:	10803fcc 	andi	r2,r2,255
 83022f0:	00000206 	br	83022fc <alt_up_audio_read_fifo_avail+0x48>
 83022f4:	e0bfff17 	ldw	r2,-4(fp)
 83022f8:	10803fcc 	andi	r2,r2,255
	fifospace = (channel == ALT_UP_AUDIO_LEFT) ? 
 83022fc:	e0bfff15 	stw	r2,-4(fp)
		(fifospace & ALT_UP_AUDIO_FIFOSPACE_RARC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_RARC_OFST;
	return (fifospace);
 8302300:	e0bfff17 	ldw	r2,-4(fp)
}
 8302304:	e037883a 	mov	sp,fp
 8302308:	df000017 	ldw	fp,0(sp)
 830230c:	dec00104 	addi	sp,sp,4
 8302310:	f800283a 	ret

08302314 <alt_up_audio_record_r>:
/* Checks if the read FIFO for the right channel has at least BUF_THRESHOLD data words 
 * available. If it doesn't, then just returns 0. If it does, then data is read from the
 * FIFO up to a maximum of len words, and stored into buf.
 */
unsigned int alt_up_audio_record_r(alt_up_audio_dev *audio, unsigned int *buf, int len)
{
 8302314:	defffa04 	addi	sp,sp,-24
 8302318:	dfc00515 	stw	ra,20(sp)
 830231c:	df000415 	stw	fp,16(sp)
 8302320:	df000404 	addi	fp,sp,16
 8302324:	e13ffe15 	stw	r4,-8(fp)
 8302328:	e17ffd15 	stw	r5,-12(fp)
 830232c:	e1bffc15 	stw	r6,-16(fp)
	unsigned int data_words = alt_up_audio_read_fifo_avail (audio, ALT_UP_AUDIO_RIGHT);
 8302330:	01400044 	movi	r5,1
 8302334:	e13ffe17 	ldw	r4,-8(fp)
 8302338:	83022b40 	call	83022b4 <alt_up_audio_read_fifo_avail>
 830233c:	e0bfff15 	stw	r2,-4(fp)
	if (data_words <= BUF_THRESHOLD)
 8302340:	e0bfff17 	ldw	r2,-4(fp)
 8302344:	10801868 	cmpgeui	r2,r2,97
 8302348:	1000021e 	bne	r2,zero,8302354 <alt_up_audio_record_r+0x40>
		return 0;
 830234c:	0005883a 	mov	r2,zero
 8302350:	00000506 	br	8302368 <alt_up_audio_record_r+0x54>
	else
		return (alt_up_audio_read_fifo(audio, buf, len, ALT_UP_AUDIO_RIGHT));
 8302354:	01c00044 	movi	r7,1
 8302358:	e1bffc17 	ldw	r6,-16(fp)
 830235c:	e17ffd17 	ldw	r5,-12(fp)
 8302360:	e13ffe17 	ldw	r4,-8(fp)
 8302364:	83025140 	call	8302514 <alt_up_audio_read_fifo>
}
 8302368:	e037883a 	mov	sp,fp
 830236c:	dfc00117 	ldw	ra,4(sp)
 8302370:	df000017 	ldw	fp,0(sp)
 8302374:	dec00204 	addi	sp,sp,8
 8302378:	f800283a 	ret

0830237c <alt_up_audio_record_l>:
/* Checks if the read FIFO for the left channel has at least BUF_THRESHOLD data words 
 * available. If it doesn't, then just returns 0. If it does, then data is read from the
 * FIFO up to a maximum of len words, and stored into buf.
 */
unsigned int alt_up_audio_record_l(alt_up_audio_dev *audio, unsigned int *buf, int len)
{
 830237c:	defffa04 	addi	sp,sp,-24
 8302380:	dfc00515 	stw	ra,20(sp)
 8302384:	df000415 	stw	fp,16(sp)
 8302388:	df000404 	addi	fp,sp,16
 830238c:	e13ffe15 	stw	r4,-8(fp)
 8302390:	e17ffd15 	stw	r5,-12(fp)
 8302394:	e1bffc15 	stw	r6,-16(fp)
	unsigned int data_words = alt_up_audio_read_fifo_avail (audio, ALT_UP_AUDIO_LEFT);
 8302398:	000b883a 	mov	r5,zero
 830239c:	e13ffe17 	ldw	r4,-8(fp)
 83023a0:	83022b40 	call	83022b4 <alt_up_audio_read_fifo_avail>
 83023a4:	e0bfff15 	stw	r2,-4(fp)
	if (data_words <= BUF_THRESHOLD)
 83023a8:	e0bfff17 	ldw	r2,-4(fp)
 83023ac:	10801868 	cmpgeui	r2,r2,97
 83023b0:	1000021e 	bne	r2,zero,83023bc <alt_up_audio_record_l+0x40>
		return 0;
 83023b4:	0005883a 	mov	r2,zero
 83023b8:	00000506 	br	83023d0 <alt_up_audio_record_l+0x54>
	else
		return (alt_up_audio_read_fifo(audio, buf, len, ALT_UP_AUDIO_LEFT));
 83023bc:	000f883a 	mov	r7,zero
 83023c0:	e1bffc17 	ldw	r6,-16(fp)
 83023c4:	e17ffd17 	ldw	r5,-12(fp)
 83023c8:	e13ffe17 	ldw	r4,-8(fp)
 83023cc:	83025140 	call	8302514 <alt_up_audio_read_fifo>
}
 83023d0:	e037883a 	mov	sp,fp
 83023d4:	dfc00117 	ldw	ra,4(sp)
 83023d8:	df000017 	ldw	fp,0(sp)
 83023dc:	dec00204 	addi	sp,sp,8
 83023e0:	f800283a 	ret

083023e4 <alt_up_audio_write_fifo_space>:

/* Provides the amount of empty space available in the outgoing FIFO: WSLC or WSRC */
unsigned int alt_up_audio_write_fifo_space(alt_up_audio_dev *audio, int channel)
{
 83023e4:	defffc04 	addi	sp,sp,-16
 83023e8:	df000315 	stw	fp,12(sp)
 83023ec:	df000304 	addi	fp,sp,12
 83023f0:	e13ffe15 	stw	r4,-8(fp)
 83023f4:	e17ffd15 	stw	r5,-12(fp)
	unsigned int fifospace;
	// read the whole fifospace register
	fifospace = IORD_ALT_UP_AUDIO_FIFOSPACE(audio->base);
 83023f8:	e0bffe17 	ldw	r2,-8(fp)
 83023fc:	10800a17 	ldw	r2,40(r2)
 8302400:	10800104 	addi	r2,r2,4
 8302404:	10800037 	ldwio	r2,0(r2)
 8302408:	e0bfff15 	stw	r2,-4(fp)
	// extract the part for proper Channel Read Space
	fifospace = (channel == ALT_UP_AUDIO_LEFT) ? 
		(fifospace & ALT_UP_AUDIO_FIFOSPACE_WSLC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_WSLC_OFST :
 830240c:	e0bffd17 	ldw	r2,-12(fp)
 8302410:	1000031e 	bne	r2,zero,8302420 <alt_up_audio_write_fifo_space+0x3c>
 8302414:	e0bfff17 	ldw	r2,-4(fp)
 8302418:	1004d63a 	srli	r2,r2,24
 830241c:	00000306 	br	830242c <alt_up_audio_write_fifo_space+0x48>
		(fifospace & ALT_UP_AUDIO_FIFOSPACE_WSRC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_WSRC_OFST;
 8302420:	e0bfff17 	ldw	r2,-4(fp)
 8302424:	1004d43a 	srli	r2,r2,16
		(fifospace & ALT_UP_AUDIO_FIFOSPACE_WSLC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_WSLC_OFST :
 8302428:	10803fcc 	andi	r2,r2,255
	fifospace = (channel == ALT_UP_AUDIO_LEFT) ? 
 830242c:	e0bfff15 	stw	r2,-4(fp)
	return (fifospace);
 8302430:	e0bfff17 	ldw	r2,-4(fp)
}
 8302434:	e037883a 	mov	sp,fp
 8302438:	df000017 	ldw	fp,0(sp)
 830243c:	dec00104 	addi	sp,sp,4
 8302440:	f800283a 	ret

08302444 <alt_up_audio_play_r>:
/* Checks if the write FIFO for the right channel has at least BUF_THRESHOLD space available.
 * If it doesn't, then just returns 0. If it does, then data from buf is written into the 
 * FIFO, up to a maximum of len words.
 */
unsigned int alt_up_audio_play_r(alt_up_audio_dev *audio, unsigned int *buf, int len)
{
 8302444:	defffa04 	addi	sp,sp,-24
 8302448:	dfc00515 	stw	ra,20(sp)
 830244c:	df000415 	stw	fp,16(sp)
 8302450:	df000404 	addi	fp,sp,16
 8302454:	e13ffe15 	stw	r4,-8(fp)
 8302458:	e17ffd15 	stw	r5,-12(fp)
 830245c:	e1bffc15 	stw	r6,-16(fp)
	unsigned int space = alt_up_audio_write_fifo_space (audio, ALT_UP_AUDIO_RIGHT);
 8302460:	01400044 	movi	r5,1
 8302464:	e13ffe17 	ldw	r4,-8(fp)
 8302468:	83023e40 	call	83023e4 <alt_up_audio_write_fifo_space>
 830246c:	e0bfff15 	stw	r2,-4(fp)
	if (space <= BUF_THRESHOLD)
 8302470:	e0bfff17 	ldw	r2,-4(fp)
 8302474:	10801868 	cmpgeui	r2,r2,97
 8302478:	1000021e 	bne	r2,zero,8302484 <alt_up_audio_play_r+0x40>
		return 0;
 830247c:	0005883a 	mov	r2,zero
 8302480:	00000506 	br	8302498 <alt_up_audio_play_r+0x54>
	else
		return (alt_up_audio_write_fifo(audio, buf, len, ALT_UP_AUDIO_RIGHT));
 8302484:	01c00044 	movi	r7,1
 8302488:	e1bffc17 	ldw	r6,-16(fp)
 830248c:	e17ffd17 	ldw	r5,-12(fp)
 8302490:	e13ffe17 	ldw	r4,-8(fp)
 8302494:	83025f40 	call	83025f4 <alt_up_audio_write_fifo>
}
 8302498:	e037883a 	mov	sp,fp
 830249c:	dfc00117 	ldw	ra,4(sp)
 83024a0:	df000017 	ldw	fp,0(sp)
 83024a4:	dec00204 	addi	sp,sp,8
 83024a8:	f800283a 	ret

083024ac <alt_up_audio_play_l>:
/* Checks if the write FIFO for the left channel has at least BUF_THRESHOLD space available.
 * If it doesn't, then just returns 0. If it does, then data from buf is written into the 
 * FIFO, up to a maximum of len words.
 */
unsigned int alt_up_audio_play_l(alt_up_audio_dev *audio, unsigned int *buf, int len)
{
 83024ac:	defffa04 	addi	sp,sp,-24
 83024b0:	dfc00515 	stw	ra,20(sp)
 83024b4:	df000415 	stw	fp,16(sp)
 83024b8:	df000404 	addi	fp,sp,16
 83024bc:	e13ffe15 	stw	r4,-8(fp)
 83024c0:	e17ffd15 	stw	r5,-12(fp)
 83024c4:	e1bffc15 	stw	r6,-16(fp)
	unsigned int space = alt_up_audio_write_fifo_space (audio, ALT_UP_AUDIO_LEFT);
 83024c8:	000b883a 	mov	r5,zero
 83024cc:	e13ffe17 	ldw	r4,-8(fp)
 83024d0:	83023e40 	call	83023e4 <alt_up_audio_write_fifo_space>
 83024d4:	e0bfff15 	stw	r2,-4(fp)
	if (space <= BUF_THRESHOLD)
 83024d8:	e0bfff17 	ldw	r2,-4(fp)
 83024dc:	10801868 	cmpgeui	r2,r2,97
 83024e0:	1000021e 	bne	r2,zero,83024ec <alt_up_audio_play_l+0x40>
		return 0;
 83024e4:	0005883a 	mov	r2,zero
 83024e8:	00000506 	br	8302500 <alt_up_audio_play_l+0x54>
	else
		return (alt_up_audio_write_fifo(audio, buf, len, ALT_UP_AUDIO_LEFT));
 83024ec:	000f883a 	mov	r7,zero
 83024f0:	e1bffc17 	ldw	r6,-16(fp)
 83024f4:	e17ffd17 	ldw	r5,-12(fp)
 83024f8:	e13ffe17 	ldw	r4,-8(fp)
 83024fc:	83025f40 	call	83025f4 <alt_up_audio_write_fifo>
}
 8302500:	e037883a 	mov	sp,fp
 8302504:	dfc00117 	ldw	ra,4(sp)
 8302508:	df000017 	ldw	fp,0(sp)
 830250c:	dec00204 	addi	sp,sp,8
 8302510:	f800283a 	ret

08302514 <alt_up_audio_read_fifo>:

int alt_up_audio_read_fifo(alt_up_audio_dev *audio, unsigned int *buf, int len, int channel)
{
 8302514:	defff904 	addi	sp,sp,-28
 8302518:	df000615 	stw	fp,24(sp)
 830251c:	df000604 	addi	fp,sp,24
 8302520:	e13ffd15 	stw	r4,-12(fp)
 8302524:	e17ffc15 	stw	r5,-16(fp)
 8302528:	e1bffb15 	stw	r6,-20(fp)
 830252c:	e1fffa15 	stw	r7,-24(fp)
	unsigned int fifospace;
	int count = 0;
 8302530:	e03fff15 	stw	zero,-4(fp)
	while ( count < len ) 
 8302534:	00002506 	br	83025cc <alt_up_audio_read_fifo+0xb8>
	{
		// read the whole fifospace register
		fifospace = IORD_ALT_UP_AUDIO_FIFOSPACE(audio->base);
 8302538:	e0bffd17 	ldw	r2,-12(fp)
 830253c:	10800a17 	ldw	r2,40(r2)
 8302540:	10800104 	addi	r2,r2,4
 8302544:	10800037 	ldwio	r2,0(r2)
 8302548:	e0bffe15 	stw	r2,-8(fp)
		// extract the part for proper Channel Read Space
		fifospace = (channel == ALT_UP_AUDIO_LEFT) ? 
			(fifospace & ALT_UP_AUDIO_FIFOSPACE_RALC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_RALC_OFST 
			:
 830254c:	e0bffa17 	ldw	r2,-24(fp)
 8302550:	1000041e 	bne	r2,zero,8302564 <alt_up_audio_read_fifo+0x50>
			(fifospace & ALT_UP_AUDIO_FIFOSPACE_RALC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_RALC_OFST 
 8302554:	e0bffe17 	ldw	r2,-8(fp)
 8302558:	1004d23a 	srli	r2,r2,8
			:
 830255c:	10803fcc 	andi	r2,r2,255
 8302560:	00000206 	br	830256c <alt_up_audio_read_fifo+0x58>
 8302564:	e0bffe17 	ldw	r2,-8(fp)
 8302568:	10803fcc 	andi	r2,r2,255
		fifospace = (channel == ALT_UP_AUDIO_LEFT) ? 
 830256c:	e0bffe15 	stw	r2,-8(fp)
			(fifospace & ALT_UP_AUDIO_FIFOSPACE_RARC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_RARC_OFST;
		if (fifospace > 0) 
 8302570:	e0bffe17 	ldw	r2,-8(fp)
 8302574:	10001926 	beq	r2,zero,83025dc <alt_up_audio_read_fifo+0xc8>
		{
			buf[count] = (channel == ALT_UP_AUDIO_LEFT) ? 
				IORD_ALT_UP_AUDIO_LEFTDATA(audio->base) :
 8302578:	e0bffa17 	ldw	r2,-24(fp)
 830257c:	1000061e 	bne	r2,zero,8302598 <alt_up_audio_read_fifo+0x84>
 8302580:	e0bffd17 	ldw	r2,-12(fp)
 8302584:	10800a17 	ldw	r2,40(r2)
 8302588:	10800204 	addi	r2,r2,8
 830258c:	10800037 	ldwio	r2,0(r2)
 8302590:	1009883a 	mov	r4,r2
 8302594:	00000506 	br	83025ac <alt_up_audio_read_fifo+0x98>
				IORD_ALT_UP_AUDIO_RIGHTDATA(audio->base);
 8302598:	e0bffd17 	ldw	r2,-12(fp)
 830259c:	10800a17 	ldw	r2,40(r2)
 83025a0:	10800304 	addi	r2,r2,12
 83025a4:	10800037 	ldwio	r2,0(r2)
				IORD_ALT_UP_AUDIO_LEFTDATA(audio->base) :
 83025a8:	1009883a 	mov	r4,r2
			buf[count] = (channel == ALT_UP_AUDIO_LEFT) ? 
 83025ac:	e0bfff17 	ldw	r2,-4(fp)
 83025b0:	100490ba 	slli	r2,r2,2
 83025b4:	e0fffc17 	ldw	r3,-16(fp)
 83025b8:	1885883a 	add	r2,r3,r2
 83025bc:	11000015 	stw	r4,0(r2)
			count ++;
 83025c0:	e0bfff17 	ldw	r2,-4(fp)
 83025c4:	10800044 	addi	r2,r2,1
 83025c8:	e0bfff15 	stw	r2,-4(fp)
	while ( count < len ) 
 83025cc:	e0ffff17 	ldw	r3,-4(fp)
 83025d0:	e0bffb17 	ldw	r2,-20(fp)
 83025d4:	18bfd816 	blt	r3,r2,8302538 <alt_up_audio_read_fifo+0x24>
 83025d8:	00000106 	br	83025e0 <alt_up_audio_read_fifo+0xcc>
		}
		else
		{
			// no more data to read
			break;
 83025dc:	0001883a 	nop
		}
	}
	return count;
 83025e0:	e0bfff17 	ldw	r2,-4(fp)
}
 83025e4:	e037883a 	mov	sp,fp
 83025e8:	df000017 	ldw	fp,0(sp)
 83025ec:	dec00104 	addi	sp,sp,4
 83025f0:	f800283a 	ret

083025f4 <alt_up_audio_write_fifo>:

int alt_up_audio_write_fifo(alt_up_audio_dev *audio, unsigned int *buf, int len, int channel)
{
 83025f4:	defff904 	addi	sp,sp,-28
 83025f8:	df000615 	stw	fp,24(sp)
 83025fc:	df000604 	addi	fp,sp,24
 8302600:	e13ffd15 	stw	r4,-12(fp)
 8302604:	e17ffc15 	stw	r5,-16(fp)
 8302608:	e1bffb15 	stw	r6,-20(fp)
 830260c:	e1fffa15 	stw	r7,-24(fp)
	unsigned int fifospace;
	int count = 0;
 8302610:	e03fff15 	stw	zero,-4(fp)
	while ( count < len ) 
 8302614:	00002b06 	br	83026c4 <alt_up_audio_write_fifo+0xd0>
	{
		// read the whole fifospace register
		fifospace = IORD_ALT_UP_AUDIO_FIFOSPACE(audio->base);
 8302618:	e0bffd17 	ldw	r2,-12(fp)
 830261c:	10800a17 	ldw	r2,40(r2)
 8302620:	10800104 	addi	r2,r2,4
 8302624:	10800037 	ldwio	r2,0(r2)
 8302628:	e0bffe15 	stw	r2,-8(fp)
		// extract the part for Left Channel Write Space 
		fifospace = (channel == ALT_UP_AUDIO_LEFT) ? 
			(fifospace & ALT_UP_AUDIO_FIFOSPACE_WSLC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_WSLC_OFST :
 830262c:	e0bffa17 	ldw	r2,-24(fp)
 8302630:	1000031e 	bne	r2,zero,8302640 <alt_up_audio_write_fifo+0x4c>
 8302634:	e0bffe17 	ldw	r2,-8(fp)
 8302638:	1004d63a 	srli	r2,r2,24
 830263c:	00000306 	br	830264c <alt_up_audio_write_fifo+0x58>
			(fifospace & ALT_UP_AUDIO_FIFOSPACE_WSRC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_WSRC_OFST;
 8302640:	e0bffe17 	ldw	r2,-8(fp)
 8302644:	1004d43a 	srli	r2,r2,16
			(fifospace & ALT_UP_AUDIO_FIFOSPACE_WSLC_MSK) >> ALT_UP_AUDIO_FIFOSPACE_WSLC_OFST :
 8302648:	10803fcc 	andi	r2,r2,255
		fifospace = (channel == ALT_UP_AUDIO_LEFT) ? 
 830264c:	e0bffe15 	stw	r2,-8(fp)
		if (fifospace > 0) 
 8302650:	e0bffe17 	ldw	r2,-8(fp)
 8302654:	10001f26 	beq	r2,zero,83026d4 <alt_up_audio_write_fifo+0xe0>
		{
			if (channel == ALT_UP_AUDIO_LEFT) 
 8302658:	e0bffa17 	ldw	r2,-24(fp)
 830265c:	10000d1e 	bne	r2,zero,8302694 <alt_up_audio_write_fifo+0xa0>
				IOWR_ALT_UP_AUDIO_LEFTDATA(audio->base, buf[count++]);
 8302660:	e0bffd17 	ldw	r2,-12(fp)
 8302664:	10800a17 	ldw	r2,40(r2)
 8302668:	10800204 	addi	r2,r2,8
 830266c:	1009883a 	mov	r4,r2
 8302670:	e0bfff17 	ldw	r2,-4(fp)
 8302674:	10c00044 	addi	r3,r2,1
 8302678:	e0ffff15 	stw	r3,-4(fp)
 830267c:	100490ba 	slli	r2,r2,2
 8302680:	e0fffc17 	ldw	r3,-16(fp)
 8302684:	1885883a 	add	r2,r3,r2
 8302688:	10800017 	ldw	r2,0(r2)
 830268c:	20800035 	stwio	r2,0(r4)
 8302690:	00000c06 	br	83026c4 <alt_up_audio_write_fifo+0xd0>
			else
				IOWR_ALT_UP_AUDIO_RIGHTDATA(audio->base, buf[count++]);
 8302694:	e0bffd17 	ldw	r2,-12(fp)
 8302698:	10800a17 	ldw	r2,40(r2)
 830269c:	10800304 	addi	r2,r2,12
 83026a0:	1009883a 	mov	r4,r2
 83026a4:	e0bfff17 	ldw	r2,-4(fp)
 83026a8:	10c00044 	addi	r3,r2,1
 83026ac:	e0ffff15 	stw	r3,-4(fp)
 83026b0:	100490ba 	slli	r2,r2,2
 83026b4:	e0fffc17 	ldw	r3,-16(fp)
 83026b8:	1885883a 	add	r2,r3,r2
 83026bc:	10800017 	ldw	r2,0(r2)
 83026c0:	20800035 	stwio	r2,0(r4)
	while ( count < len ) 
 83026c4:	e0ffff17 	ldw	r3,-4(fp)
 83026c8:	e0bffb17 	ldw	r2,-20(fp)
 83026cc:	18bfd216 	blt	r3,r2,8302618 <alt_up_audio_write_fifo+0x24>
 83026d0:	00000106 	br	83026d8 <alt_up_audio_write_fifo+0xe4>
		}
		else
		{
			// no more space to write
			break;
 83026d4:	0001883a 	nop
		}
	}
	return count;
 83026d8:	e0bfff17 	ldw	r2,-4(fp)
}
 83026dc:	e037883a 	mov	sp,fp
 83026e0:	df000017 	ldw	fp,0(sp)
 83026e4:	dec00104 	addi	sp,sp,4
 83026e8:	f800283a 	ret

083026ec <alt_up_audio_read_fifo_head>:

unsigned int alt_up_audio_read_fifo_head(alt_up_audio_dev *audio, int channel)
{
 83026ec:	defffd04 	addi	sp,sp,-12
 83026f0:	df000215 	stw	fp,8(sp)
 83026f4:	df000204 	addi	fp,sp,8
 83026f8:	e13fff15 	stw	r4,-4(fp)
 83026fc:	e17ffe15 	stw	r5,-8(fp)
	return ( (channel == ALT_UP_AUDIO_LEFT) ?  IORD_ALT_UP_AUDIO_LEFTDATA(audio->base) :
 8302700:	e0bffe17 	ldw	r2,-8(fp)
 8302704:	1000051e 	bne	r2,zero,830271c <alt_up_audio_read_fifo_head+0x30>
 8302708:	e0bfff17 	ldw	r2,-4(fp)
 830270c:	10800a17 	ldw	r2,40(r2)
 8302710:	10800204 	addi	r2,r2,8
 8302714:	10800037 	ldwio	r2,0(r2)
 8302718:	00000406 	br	830272c <alt_up_audio_read_fifo_head+0x40>
				IORD_ALT_UP_AUDIO_RIGHTDATA(audio->base) );
 830271c:	e0bfff17 	ldw	r2,-4(fp)
 8302720:	10800a17 	ldw	r2,40(r2)
 8302724:	10800304 	addi	r2,r2,12
 8302728:	10800037 	ldwio	r2,0(r2)
}
 830272c:	e037883a 	mov	sp,fp
 8302730:	df000017 	ldw	fp,0(sp)
 8302734:	dec00104 	addi	sp,sp,4
 8302738:	f800283a 	ret

0830273c <alt_up_audio_write_fifo_head>:

void alt_up_audio_write_fifo_head(alt_up_audio_dev *audio, unsigned int data, int channel)
{
 830273c:	defffc04 	addi	sp,sp,-16
 8302740:	df000315 	stw	fp,12(sp)
 8302744:	df000304 	addi	fp,sp,12
 8302748:	e13fff15 	stw	r4,-4(fp)
 830274c:	e17ffe15 	stw	r5,-8(fp)
 8302750:	e1bffd15 	stw	r6,-12(fp)
	if (channel == ALT_UP_AUDIO_LEFT) 
 8302754:	e0bffd17 	ldw	r2,-12(fp)
 8302758:	1000071e 	bne	r2,zero,8302778 <alt_up_audio_write_fifo_head+0x3c>
		IOWR_ALT_UP_AUDIO_LEFTDATA(audio->base, data);
 830275c:	e0bfff17 	ldw	r2,-4(fp)
 8302760:	10800a17 	ldw	r2,40(r2)
 8302764:	10800204 	addi	r2,r2,8
 8302768:	1007883a 	mov	r3,r2
 830276c:	e0bffe17 	ldw	r2,-8(fp)
 8302770:	18800035 	stwio	r2,0(r3)
	else
		IOWR_ALT_UP_AUDIO_RIGHTDATA(audio->base, data);
}
 8302774:	00000606 	br	8302790 <alt_up_audio_write_fifo_head+0x54>
		IOWR_ALT_UP_AUDIO_RIGHTDATA(audio->base, data);
 8302778:	e0bfff17 	ldw	r2,-4(fp)
 830277c:	10800a17 	ldw	r2,40(r2)
 8302780:	10800304 	addi	r2,r2,12
 8302784:	1007883a 	mov	r3,r2
 8302788:	e0bffe17 	ldw	r2,-8(fp)
 830278c:	18800035 	stwio	r2,0(r3)
}
 8302790:	0001883a 	nop
 8302794:	e037883a 	mov	sp,fp
 8302798:	df000017 	ldw	fp,0(sp)
 830279c:	dec00104 	addi	sp,sp,4
 83027a0:	f800283a 	ret

083027a4 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 83027a4:	defff504 	addi	sp,sp,-44
 83027a8:	df000a15 	stw	fp,40(sp)
 83027ac:	df000a04 	addi	fp,sp,40
 83027b0:	e13ff915 	stw	r4,-28(fp)
 83027b4:	e17ff815 	stw	r5,-32(fp)
 83027b8:	e1bff715 	stw	r6,-36(fp)
 83027bc:	e1fff615 	stw	r7,-40(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 83027c0:	e03fff15 	stw	zero,-4(fp)
  return _alt_tick_rate;
 83027c4:	d0a5e917 	ldw	r2,-26716(gp)
  
  if (alt_ticks_per_second ())
 83027c8:	10003e26 	beq	r2,zero,83028c4 <alt_alarm_start+0x120>
  {
    if (alarm)
 83027cc:	e0bff917 	ldw	r2,-28(fp)
 83027d0:	10003a26 	beq	r2,zero,83028bc <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
 83027d4:	e0bff917 	ldw	r2,-28(fp)
 83027d8:	e0fff717 	ldw	r3,-36(fp)
 83027dc:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 83027e0:	e0bff917 	ldw	r2,-28(fp)
 83027e4:	e0fff617 	ldw	r3,-40(fp)
 83027e8:	10c00515 	stw	r3,20(r2)
  NIOS2_READ_STATUS (context);
 83027ec:	0005303a 	rdctl	r2,status
 83027f0:	e0bffd15 	stw	r2,-12(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 83027f4:	e0fffd17 	ldw	r3,-12(fp)
 83027f8:	00bfff84 	movi	r2,-2
 83027fc:	1884703a 	and	r2,r3,r2
 8302800:	1001703a 	wrctl	status,r2
  return context;
 8302804:	e0bffd17 	ldw	r2,-12(fp)
 
      irq_context = alt_irq_disable_all ();
 8302808:	e0bffe15 	stw	r2,-8(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 830280c:	d0a5ea17 	ldw	r2,-26712(gp)
      
      current_nticks = alt_nticks();
 8302810:	e0bfff15 	stw	r2,-4(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 8302814:	e0fff817 	ldw	r3,-32(fp)
 8302818:	e0bfff17 	ldw	r2,-4(fp)
 830281c:	1885883a 	add	r2,r3,r2
 8302820:	10c00044 	addi	r3,r2,1
 8302824:	e0bff917 	ldw	r2,-28(fp)
 8302828:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 830282c:	e0bff917 	ldw	r2,-28(fp)
 8302830:	10c00217 	ldw	r3,8(r2)
 8302834:	e0bfff17 	ldw	r2,-4(fp)
 8302838:	1880042e 	bgeu	r3,r2,830284c <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 830283c:	e0bff917 	ldw	r2,-28(fp)
 8302840:	00c00044 	movi	r3,1
 8302844:	10c00405 	stb	r3,16(r2)
 8302848:	00000206 	br	8302854 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 830284c:	e0bff917 	ldw	r2,-28(fp)
 8302850:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 8302854:	e0bff917 	ldw	r2,-28(fp)
 8302858:	d0e00904 	addi	r3,gp,-32732
 830285c:	e0fffb15 	stw	r3,-20(fp)
 8302860:	e0bffa15 	stw	r2,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 8302864:	e0bffa17 	ldw	r2,-24(fp)
 8302868:	e0fffb17 	ldw	r3,-20(fp)
 830286c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 8302870:	e0bffb17 	ldw	r2,-20(fp)
 8302874:	10c00017 	ldw	r3,0(r2)
 8302878:	e0bffa17 	ldw	r2,-24(fp)
 830287c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 8302880:	e0bffb17 	ldw	r2,-20(fp)
 8302884:	10800017 	ldw	r2,0(r2)
 8302888:	e0fffa17 	ldw	r3,-24(fp)
 830288c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 8302890:	e0bffb17 	ldw	r2,-20(fp)
 8302894:	e0fffa17 	ldw	r3,-24(fp)
 8302898:	10c00015 	stw	r3,0(r2)
}
 830289c:	0001883a 	nop
 83028a0:	e0bffe17 	ldw	r2,-8(fp)
 83028a4:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context);
 83028a8:	e0bffc17 	ldw	r2,-16(fp)
 83028ac:	1001703a 	wrctl	status,r2
}
 83028b0:	0001883a 	nop
      alt_irq_enable_all (irq_context);

      return 0;
 83028b4:	0005883a 	mov	r2,zero
 83028b8:	00000306 	br	83028c8 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
 83028bc:	00bffa84 	movi	r2,-22
 83028c0:	00000106 	br	83028c8 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
 83028c4:	00bfde84 	movi	r2,-134
  }
}
 83028c8:	e037883a 	mov	sp,fp
 83028cc:	df000017 	ldw	fp,0(sp)
 83028d0:	dec00104 	addi	sp,sp,4
 83028d4:	f800283a 	ret

083028d8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 83028d8:	defffe04 	addi	sp,sp,-8
 83028dc:	dfc00115 	stw	ra,4(sp)
 83028e0:	df000015 	stw	fp,0(sp)
 83028e4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 83028e8:	d0a00817 	ldw	r2,-32736(gp)
 83028ec:	10000326 	beq	r2,zero,83028fc <alt_get_errno+0x24>
 83028f0:	d0a00817 	ldw	r2,-32736(gp)
 83028f4:	103ee83a 	callr	r2
 83028f8:	00000106 	br	8302900 <alt_get_errno+0x28>
 83028fc:	d0a5ec04 	addi	r2,gp,-26704
}
 8302900:	e037883a 	mov	sp,fp
 8302904:	dfc00117 	ldw	ra,4(sp)
 8302908:	df000017 	ldw	fp,0(sp)
 830290c:	dec00204 	addi	sp,sp,8
 8302910:	f800283a 	ret

08302914 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 8302914:	defffb04 	addi	sp,sp,-20
 8302918:	dfc00415 	stw	ra,16(sp)
 830291c:	df000315 	stw	fp,12(sp)
 8302920:	df000304 	addi	fp,sp,12
 8302924:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 8302928:	e0bffd17 	ldw	r2,-12(fp)
 830292c:	10000916 	blt	r2,zero,8302954 <close+0x40>
 8302930:	e0fffd17 	ldw	r3,-12(fp)
 8302934:	1805883a 	mov	r2,r3
 8302938:	1085883a 	add	r2,r2,r2
 830293c:	10c5883a 	add	r2,r2,r3
 8302940:	100490ba 	slli	r2,r2,2
 8302944:	00c20c34 	movhi	r3,2096
 8302948:	18d2d904 	addi	r3,r3,19300
 830294c:	10c5883a 	add	r2,r2,r3
 8302950:	00000106 	br	8302958 <close+0x44>
 8302954:	0005883a 	mov	r2,zero
 8302958:	e0bfff15 	stw	r2,-4(fp)

  if (fd)
 830295c:	e0bfff17 	ldw	r2,-4(fp)
 8302960:	10001926 	beq	r2,zero,83029c8 <close+0xb4>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 8302964:	e0bfff17 	ldw	r2,-4(fp)
 8302968:	10800017 	ldw	r2,0(r2)
 830296c:	10800417 	ldw	r2,16(r2)
 8302970:	10000626 	beq	r2,zero,830298c <close+0x78>
 8302974:	e0bfff17 	ldw	r2,-4(fp)
 8302978:	10800017 	ldw	r2,0(r2)
 830297c:	10800417 	ldw	r2,16(r2)
 8302980:	e13fff17 	ldw	r4,-4(fp)
 8302984:	103ee83a 	callr	r2
 8302988:	00000106 	br	8302990 <close+0x7c>
 830298c:	0005883a 	mov	r2,zero
 8302990:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 8302994:	e13ffd17 	ldw	r4,-12(fp)
 8302998:	83030600 	call	8303060 <alt_release_fd>
    if (rval < 0)
 830299c:	e0bffe17 	ldw	r2,-8(fp)
 83029a0:	1000070e 	bge	r2,zero,83029c0 <close+0xac>
    {
      ALT_ERRNO = -rval;
 83029a4:	83028d80 	call	83028d8 <alt_get_errno>
 83029a8:	1007883a 	mov	r3,r2
 83029ac:	e0bffe17 	ldw	r2,-8(fp)
 83029b0:	0085c83a 	sub	r2,zero,r2
 83029b4:	18800015 	stw	r2,0(r3)
      return -1;
 83029b8:	00bfffc4 	movi	r2,-1
 83029bc:	00000706 	br	83029dc <close+0xc8>
    }
    return 0;
 83029c0:	0005883a 	mov	r2,zero
 83029c4:	00000506 	br	83029dc <close+0xc8>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 83029c8:	83028d80 	call	83028d8 <alt_get_errno>
 83029cc:	1007883a 	mov	r3,r2
 83029d0:	00801444 	movi	r2,81
 83029d4:	18800015 	stw	r2,0(r3)
    return -1;
 83029d8:	00bfffc4 	movi	r2,-1
  }
}
 83029dc:	e037883a 	mov	sp,fp
 83029e0:	dfc00117 	ldw	ra,4(sp)
 83029e4:	df000017 	ldw	fp,0(sp)
 83029e8:	dec00204 	addi	sp,sp,8
 83029ec:	f800283a 	ret

083029f0 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 83029f0:	deffff04 	addi	sp,sp,-4
 83029f4:	df000015 	stw	fp,0(sp)
 83029f8:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 83029fc:	0001883a 	nop
 8302a00:	e037883a 	mov	sp,fp
 8302a04:	df000017 	ldw	fp,0(sp)
 8302a08:	dec00104 	addi	sp,sp,4
 8302a0c:	f800283a 	ret

08302a10 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 8302a10:	defffc04 	addi	sp,sp,-16
 8302a14:	df000315 	stw	fp,12(sp)
 8302a18:	df000304 	addi	fp,sp,12
 8302a1c:	e13fff15 	stw	r4,-4(fp)
 8302a20:	e17ffe15 	stw	r5,-8(fp)
 8302a24:	e1bffd15 	stw	r6,-12(fp)
  return len;
 8302a28:	e0bffd17 	ldw	r2,-12(fp)
}
 8302a2c:	e037883a 	mov	sp,fp
 8302a30:	df000017 	ldw	fp,0(sp)
 8302a34:	dec00104 	addi	sp,sp,4
 8302a38:	f800283a 	ret

08302a3c <alt_get_errno>:
 8302a3c:	defffe04 	addi	sp,sp,-8
 8302a40:	dfc00115 	stw	ra,4(sp)
 8302a44:	df000015 	stw	fp,0(sp)
 8302a48:	d839883a 	mov	fp,sp
 8302a4c:	d0a00817 	ldw	r2,-32736(gp)
 8302a50:	10000326 	beq	r2,zero,8302a60 <alt_get_errno+0x24>
 8302a54:	d0a00817 	ldw	r2,-32736(gp)
 8302a58:	103ee83a 	callr	r2
 8302a5c:	00000106 	br	8302a64 <alt_get_errno+0x28>
 8302a60:	d0a5ec04 	addi	r2,gp,-26704
 8302a64:	e037883a 	mov	sp,fp
 8302a68:	dfc00117 	ldw	ra,4(sp)
 8302a6c:	df000017 	ldw	fp,0(sp)
 8302a70:	dec00204 	addi	sp,sp,8
 8302a74:	f800283a 	ret

08302a78 <alt_dev_llist_insert>:
 8302a78:	defffa04 	addi	sp,sp,-24
 8302a7c:	dfc00515 	stw	ra,20(sp)
 8302a80:	df000415 	stw	fp,16(sp)
 8302a84:	df000404 	addi	fp,sp,16
 8302a88:	e13ffd15 	stw	r4,-12(fp)
 8302a8c:	e17ffc15 	stw	r5,-16(fp)
 8302a90:	e0bffd17 	ldw	r2,-12(fp)
 8302a94:	10000326 	beq	r2,zero,8302aa4 <alt_dev_llist_insert+0x2c>
 8302a98:	e0bffd17 	ldw	r2,-12(fp)
 8302a9c:	10800217 	ldw	r2,8(r2)
 8302aa0:	1000061e 	bne	r2,zero,8302abc <alt_dev_llist_insert+0x44>
 8302aa4:	8302a3c0 	call	8302a3c <alt_get_errno>
 8302aa8:	1007883a 	mov	r3,r2
 8302aac:	00800584 	movi	r2,22
 8302ab0:	18800015 	stw	r2,0(r3)
 8302ab4:	00bffa84 	movi	r2,-22
 8302ab8:	00001406 	br	8302b0c <alt_dev_llist_insert+0x94>
 8302abc:	e0bffd17 	ldw	r2,-12(fp)
 8302ac0:	e0fffc17 	ldw	r3,-16(fp)
 8302ac4:	e0ffff15 	stw	r3,-4(fp)
 8302ac8:	e0bffe15 	stw	r2,-8(fp)
 8302acc:	e0bffe17 	ldw	r2,-8(fp)
 8302ad0:	e0ffff17 	ldw	r3,-4(fp)
 8302ad4:	10c00115 	stw	r3,4(r2)
 8302ad8:	e0bfff17 	ldw	r2,-4(fp)
 8302adc:	10c00017 	ldw	r3,0(r2)
 8302ae0:	e0bffe17 	ldw	r2,-8(fp)
 8302ae4:	10c00015 	stw	r3,0(r2)
 8302ae8:	e0bfff17 	ldw	r2,-4(fp)
 8302aec:	10800017 	ldw	r2,0(r2)
 8302af0:	e0fffe17 	ldw	r3,-8(fp)
 8302af4:	10c00115 	stw	r3,4(r2)
 8302af8:	e0bfff17 	ldw	r2,-4(fp)
 8302afc:	e0fffe17 	ldw	r3,-8(fp)
 8302b00:	10c00015 	stw	r3,0(r2)
 8302b04:	0001883a 	nop
 8302b08:	0005883a 	mov	r2,zero
 8302b0c:	e037883a 	mov	sp,fp
 8302b10:	dfc00117 	ldw	ra,4(sp)
 8302b14:	df000017 	ldw	fp,0(sp)
 8302b18:	dec00204 	addi	sp,sp,8
 8302b1c:	f800283a 	ret

08302b20 <_do_ctors>:
 8302b20:	defffd04 	addi	sp,sp,-12
 8302b24:	dfc00215 	stw	ra,8(sp)
 8302b28:	df000115 	stw	fp,4(sp)
 8302b2c:	df000104 	addi	fp,sp,4
 8302b30:	00820c34 	movhi	r2,2096
 8302b34:	108e4d04 	addi	r2,r2,14644
 8302b38:	e0bfff15 	stw	r2,-4(fp)
 8302b3c:	00000606 	br	8302b58 <_do_ctors+0x38>
 8302b40:	e0bfff17 	ldw	r2,-4(fp)
 8302b44:	10800017 	ldw	r2,0(r2)
 8302b48:	103ee83a 	callr	r2
 8302b4c:	e0bfff17 	ldw	r2,-4(fp)
 8302b50:	10bfff04 	addi	r2,r2,-4
 8302b54:	e0bfff15 	stw	r2,-4(fp)
 8302b58:	e0ffff17 	ldw	r3,-4(fp)
 8302b5c:	00820c34 	movhi	r2,2096
 8302b60:	108e4e04 	addi	r2,r2,14648
 8302b64:	18bff62e 	bgeu	r3,r2,8302b40 <_do_ctors+0x20>
 8302b68:	0001883a 	nop
 8302b6c:	0001883a 	nop
 8302b70:	e037883a 	mov	sp,fp
 8302b74:	dfc00117 	ldw	ra,4(sp)
 8302b78:	df000017 	ldw	fp,0(sp)
 8302b7c:	dec00204 	addi	sp,sp,8
 8302b80:	f800283a 	ret

08302b84 <_do_dtors>:
 8302b84:	defffd04 	addi	sp,sp,-12
 8302b88:	dfc00215 	stw	ra,8(sp)
 8302b8c:	df000115 	stw	fp,4(sp)
 8302b90:	df000104 	addi	fp,sp,4
 8302b94:	00820c34 	movhi	r2,2096
 8302b98:	108e4d04 	addi	r2,r2,14644
 8302b9c:	e0bfff15 	stw	r2,-4(fp)
 8302ba0:	00000606 	br	8302bbc <_do_dtors+0x38>
 8302ba4:	e0bfff17 	ldw	r2,-4(fp)
 8302ba8:	10800017 	ldw	r2,0(r2)
 8302bac:	103ee83a 	callr	r2
 8302bb0:	e0bfff17 	ldw	r2,-4(fp)
 8302bb4:	10bfff04 	addi	r2,r2,-4
 8302bb8:	e0bfff15 	stw	r2,-4(fp)
 8302bbc:	e0ffff17 	ldw	r3,-4(fp)
 8302bc0:	00820c34 	movhi	r2,2096
 8302bc4:	108e4e04 	addi	r2,r2,14648
 8302bc8:	18bff62e 	bgeu	r3,r2,8302ba4 <_do_dtors+0x20>
 8302bcc:	0001883a 	nop
 8302bd0:	0001883a 	nop
 8302bd4:	e037883a 	mov	sp,fp
 8302bd8:	dfc00117 	ldw	ra,4(sp)
 8302bdc:	df000017 	ldw	fp,0(sp)
 8302be0:	dec00204 	addi	sp,sp,8
 8302be4:	f800283a 	ret

08302be8 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 8302be8:	defffa04 	addi	sp,sp,-24
 8302bec:	dfc00515 	stw	ra,20(sp)
 8302bf0:	df000415 	stw	fp,16(sp)
 8302bf4:	df000404 	addi	fp,sp,16
 8302bf8:	e13ffd15 	stw	r4,-12(fp)
 8302bfc:	e17ffc15 	stw	r5,-16(fp)
  alt_dev* next = (alt_dev*) llist->next;
 8302c00:	e0bffc17 	ldw	r2,-16(fp)
 8302c04:	10800017 	ldw	r2,0(r2)
 8302c08:	e0bfff15 	stw	r2,-4(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 8302c0c:	e13ffd17 	ldw	r4,-12(fp)
 8302c10:	83036b80 	call	83036b8 <strlen>
 8302c14:	10800044 	addi	r2,r2,1
 8302c18:	e0bffe15 	stw	r2,-8(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 8302c1c:	00000d06 	br	8302c54 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 8302c20:	e0bfff17 	ldw	r2,-4(fp)
 8302c24:	10800217 	ldw	r2,8(r2)
 8302c28:	e0fffe17 	ldw	r3,-8(fp)
 8302c2c:	180d883a 	mov	r6,r3
 8302c30:	e17ffd17 	ldw	r5,-12(fp)
 8302c34:	1009883a 	mov	r4,r2
 8302c38:	83035400 	call	8303540 <memcmp>
 8302c3c:	1000021e 	bne	r2,zero,8302c48 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 8302c40:	e0bfff17 	ldw	r2,-4(fp)
 8302c44:	00000706 	br	8302c64 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 8302c48:	e0bfff17 	ldw	r2,-4(fp)
 8302c4c:	10800017 	ldw	r2,0(r2)
 8302c50:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) llist)
 8302c54:	e0ffff17 	ldw	r3,-4(fp)
 8302c58:	e0bffc17 	ldw	r2,-16(fp)
 8302c5c:	18bff01e 	bne	r3,r2,8302c20 <alt_find_dev+0x38>
  }
  
  /* No match found */
  
  return NULL;
 8302c60:	0005883a 	mov	r2,zero
}
 8302c64:	e037883a 	mov	sp,fp
 8302c68:	dfc00117 	ldw	ra,4(sp)
 8302c6c:	df000017 	ldw	fp,0(sp)
 8302c70:	dec00204 	addi	sp,sp,8
 8302c74:	f800283a 	ret

08302c78 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 8302c78:	deffff04 	addi	sp,sp,-4
 8302c7c:	df000015 	stw	fp,0(sp)
 8302c80:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
 8302c84:	0001883a 	nop
 8302c88:	e037883a 	mov	sp,fp
 8302c8c:	df000017 	ldw	fp,0(sp)
 8302c90:	dec00104 	addi	sp,sp,4
 8302c94:	f800283a 	ret

08302c98 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 8302c98:	defff904 	addi	sp,sp,-28
 8302c9c:	dfc00615 	stw	ra,24(sp)
 8302ca0:	df000515 	stw	fp,20(sp)
 8302ca4:	df000504 	addi	fp,sp,20
 8302ca8:	e13ffe15 	stw	r4,-8(fp)
 8302cac:	e17ffd15 	stw	r5,-12(fp)
 8302cb0:	e1bffc15 	stw	r6,-16(fp)
 8302cb4:	e1fffb15 	stw	r7,-20(fp)
  int old;

  old = open (name, flags, mode);
 8302cb8:	e1bffb17 	ldw	r6,-20(fp)
 8302cbc:	e17ffc17 	ldw	r5,-16(fp)
 8302cc0:	e13ffd17 	ldw	r4,-12(fp)
 8302cc4:	8302f000 	call	8302f00 <open>
 8302cc8:	e0bfff15 	stw	r2,-4(fp)

  if (old >= 0)
 8302ccc:	e0bfff17 	ldw	r2,-4(fp)
 8302cd0:	10002016 	blt	r2,zero,8302d54 <alt_open_fd+0xbc>
  {
    fd->dev      = alt_fd_list[old].dev;
 8302cd4:	e0ffff17 	ldw	r3,-4(fp)
 8302cd8:	1805883a 	mov	r2,r3
 8302cdc:	1085883a 	add	r2,r2,r2
 8302ce0:	10c5883a 	add	r2,r2,r3
 8302ce4:	100490ba 	slli	r2,r2,2
 8302ce8:	00c20c34 	movhi	r3,2096
 8302cec:	10c7883a 	add	r3,r2,r3
 8302cf0:	18d2d917 	ldw	r3,19300(r3)
 8302cf4:	e0bffe17 	ldw	r2,-8(fp)
 8302cf8:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 8302cfc:	e0ffff17 	ldw	r3,-4(fp)
 8302d00:	1805883a 	mov	r2,r3
 8302d04:	1085883a 	add	r2,r2,r2
 8302d08:	10c5883a 	add	r2,r2,r3
 8302d0c:	100490ba 	slli	r2,r2,2
 8302d10:	00c20c34 	movhi	r3,2096
 8302d14:	10c7883a 	add	r3,r2,r3
 8302d18:	18d2da17 	ldw	r3,19304(r3)
 8302d1c:	e0bffe17 	ldw	r2,-8(fp)
 8302d20:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 8302d24:	e0ffff17 	ldw	r3,-4(fp)
 8302d28:	1805883a 	mov	r2,r3
 8302d2c:	1085883a 	add	r2,r2,r2
 8302d30:	10c5883a 	add	r2,r2,r3
 8302d34:	100490ba 	slli	r2,r2,2
 8302d38:	00c20c34 	movhi	r3,2096
 8302d3c:	10c7883a 	add	r3,r2,r3
 8302d40:	18d2db17 	ldw	r3,19308(r3)
 8302d44:	e0bffe17 	ldw	r2,-8(fp)
 8302d48:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 8302d4c:	e13fff17 	ldw	r4,-4(fp)
 8302d50:	83030600 	call	8303060 <alt_release_fd>
  }
} 
 8302d54:	0001883a 	nop
 8302d58:	e037883a 	mov	sp,fp
 8302d5c:	dfc00117 	ldw	ra,4(sp)
 8302d60:	df000017 	ldw	fp,0(sp)
 8302d64:	dec00204 	addi	sp,sp,8
 8302d68:	f800283a 	ret

08302d6c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 8302d6c:	defffb04 	addi	sp,sp,-20
 8302d70:	dfc00415 	stw	ra,16(sp)
 8302d74:	df000315 	stw	fp,12(sp)
 8302d78:	df000304 	addi	fp,sp,12
 8302d7c:	e13fff15 	stw	r4,-4(fp)
 8302d80:	e17ffe15 	stw	r5,-8(fp)
 8302d84:	e1bffd15 	stw	r6,-12(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 8302d88:	01c07fc4 	movi	r7,511
 8302d8c:	01800044 	movi	r6,1
 8302d90:	e17fff17 	ldw	r5,-4(fp)
 8302d94:	01020c34 	movhi	r4,2096
 8302d98:	2112dc04 	addi	r4,r4,19312
 8302d9c:	8302c980 	call	8302c98 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 8302da0:	01c07fc4 	movi	r7,511
 8302da4:	000d883a 	mov	r6,zero
 8302da8:	e17ffe17 	ldw	r5,-8(fp)
 8302dac:	01020c34 	movhi	r4,2096
 8302db0:	2112d904 	addi	r4,r4,19300
 8302db4:	8302c980 	call	8302c98 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 8302db8:	01c07fc4 	movi	r7,511
 8302dbc:	01800044 	movi	r6,1
 8302dc0:	e17ffd17 	ldw	r5,-12(fp)
 8302dc4:	01020c34 	movhi	r4,2096
 8302dc8:	2112df04 	addi	r4,r4,19324
 8302dcc:	8302c980 	call	8302c98 <alt_open_fd>
}  
 8302dd0:	0001883a 	nop
 8302dd4:	e037883a 	mov	sp,fp
 8302dd8:	dfc00117 	ldw	ra,4(sp)
 8302ddc:	df000017 	ldw	fp,0(sp)
 8302de0:	dec00204 	addi	sp,sp,8
 8302de4:	f800283a 	ret

08302de8 <alt_get_errno>:
{
 8302de8:	defffe04 	addi	sp,sp,-8
 8302dec:	dfc00115 	stw	ra,4(sp)
 8302df0:	df000015 	stw	fp,0(sp)
 8302df4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 8302df8:	d0a00817 	ldw	r2,-32736(gp)
 8302dfc:	10000326 	beq	r2,zero,8302e0c <alt_get_errno+0x24>
 8302e00:	d0a00817 	ldw	r2,-32736(gp)
 8302e04:	103ee83a 	callr	r2
 8302e08:	00000106 	br	8302e10 <alt_get_errno+0x28>
 8302e0c:	d0a5ec04 	addi	r2,gp,-26704
}
 8302e10:	e037883a 	mov	sp,fp
 8302e14:	dfc00117 	ldw	ra,4(sp)
 8302e18:	df000017 	ldw	fp,0(sp)
 8302e1c:	dec00204 	addi	sp,sp,8
 8302e20:	f800283a 	ret

08302e24 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 8302e24:	defffd04 	addi	sp,sp,-12
 8302e28:	df000215 	stw	fp,8(sp)
 8302e2c:	df000204 	addi	fp,sp,8
 8302e30:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 8302e34:	e0bffe17 	ldw	r2,-8(fp)
 8302e38:	10800217 	ldw	r2,8(r2)
 8302e3c:	10d00034 	orhi	r3,r2,16384
 8302e40:	e0bffe17 	ldw	r2,-8(fp)
 8302e44:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 8302e48:	e03fff15 	stw	zero,-4(fp)
 8302e4c:	00002306 	br	8302edc <alt_file_locked+0xb8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 8302e50:	e0ffff17 	ldw	r3,-4(fp)
 8302e54:	1805883a 	mov	r2,r3
 8302e58:	1085883a 	add	r2,r2,r2
 8302e5c:	10c5883a 	add	r2,r2,r3
 8302e60:	100490ba 	slli	r2,r2,2
 8302e64:	00c20c34 	movhi	r3,2096
 8302e68:	10c7883a 	add	r3,r2,r3
 8302e6c:	18d2d917 	ldw	r3,19300(r3)
 8302e70:	e0bffe17 	ldw	r2,-8(fp)
 8302e74:	10800017 	ldw	r2,0(r2)
 8302e78:	1880151e 	bne	r3,r2,8302ed0 <alt_file_locked+0xac>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 8302e7c:	e0ffff17 	ldw	r3,-4(fp)
 8302e80:	1805883a 	mov	r2,r3
 8302e84:	1085883a 	add	r2,r2,r2
 8302e88:	10c5883a 	add	r2,r2,r3
 8302e8c:	100490ba 	slli	r2,r2,2
 8302e90:	00c20c34 	movhi	r3,2096
 8302e94:	10c7883a 	add	r3,r2,r3
 8302e98:	1892db17 	ldw	r2,19308(r3)
    if ((alt_fd_list[i].dev == fd->dev) &&
 8302e9c:	10000c0e 	bge	r2,zero,8302ed0 <alt_file_locked+0xac>
        (&alt_fd_list[i] != fd))
 8302ea0:	e0ffff17 	ldw	r3,-4(fp)
 8302ea4:	1805883a 	mov	r2,r3
 8302ea8:	1085883a 	add	r2,r2,r2
 8302eac:	10c5883a 	add	r2,r2,r3
 8302eb0:	100490ba 	slli	r2,r2,2
 8302eb4:	00c20c34 	movhi	r3,2096
 8302eb8:	18d2d904 	addi	r3,r3,19300
 8302ebc:	10c5883a 	add	r2,r2,r3
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 8302ec0:	e0fffe17 	ldw	r3,-8(fp)
 8302ec4:	18800226 	beq	r3,r2,8302ed0 <alt_file_locked+0xac>
    {
      return -EACCES;
 8302ec8:	00bffcc4 	movi	r2,-13
 8302ecc:	00000806 	br	8302ef0 <alt_file_locked+0xcc>
  for (i = 0; i <= alt_max_fd; i++)
 8302ed0:	e0bfff17 	ldw	r2,-4(fp)
 8302ed4:	10800044 	addi	r2,r2,1
 8302ed8:	e0bfff15 	stw	r2,-4(fp)
 8302edc:	d0a00717 	ldw	r2,-32740(gp)
 8302ee0:	1007883a 	mov	r3,r2
 8302ee4:	e0bfff17 	ldw	r2,-4(fp)
 8302ee8:	18bfd92e 	bgeu	r3,r2,8302e50 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 8302eec:	0005883a 	mov	r2,zero
}
 8302ef0:	e037883a 	mov	sp,fp
 8302ef4:	df000017 	ldw	fp,0(sp)
 8302ef8:	dec00104 	addi	sp,sp,4
 8302efc:	f800283a 	ret

08302f00 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 8302f00:	defff604 	addi	sp,sp,-40
 8302f04:	dfc00915 	stw	ra,36(sp)
 8302f08:	df000815 	stw	fp,32(sp)
 8302f0c:	df000804 	addi	fp,sp,32
 8302f10:	e13ffa15 	stw	r4,-24(fp)
 8302f14:	e17ff915 	stw	r5,-28(fp)
 8302f18:	e1bff815 	stw	r6,-32(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 8302f1c:	00bfffc4 	movi	r2,-1
 8302f20:	e0bffe15 	stw	r2,-8(fp)
  int status = -ENODEV;
 8302f24:	00bffb44 	movi	r2,-19
 8302f28:	e0bffd15 	stw	r2,-12(fp)
  int isafs = 0;
 8302f2c:	e03ffc15 	stw	zero,-16(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 8302f30:	d1600504 	addi	r5,gp,-32748
 8302f34:	e13ffa17 	ldw	r4,-24(fp)
 8302f38:	8302be80 	call	8302be8 <alt_find_dev>
 8302f3c:	e0bfff15 	stw	r2,-4(fp)
 8302f40:	e0bfff17 	ldw	r2,-4(fp)
 8302f44:	1000051e 	bne	r2,zero,8302f5c <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 8302f48:	e13ffa17 	ldw	r4,-24(fp)
 8302f4c:	83032a00 	call	83032a0 <alt_find_file>
 8302f50:	e0bfff15 	stw	r2,-4(fp)
    isafs = 1;
 8302f54:	00800044 	movi	r2,1
 8302f58:	e0bffc15 	stw	r2,-16(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 8302f5c:	e0bfff17 	ldw	r2,-4(fp)
 8302f60:	10002c26 	beq	r2,zero,8303014 <open+0x114>
  {
    if ((index = alt_get_fd (dev)) < 0)
 8302f64:	e13fff17 	ldw	r4,-4(fp)
 8302f68:	83033a80 	call	83033a8 <alt_get_fd>
 8302f6c:	e0bffe15 	stw	r2,-8(fp)
 8302f70:	e0bffe17 	ldw	r2,-8(fp)
 8302f74:	1000030e 	bge	r2,zero,8302f84 <open+0x84>
    {
      status = index;
 8302f78:	e0bffe17 	ldw	r2,-8(fp)
 8302f7c:	e0bffd15 	stw	r2,-12(fp)
 8302f80:	00002606 	br	830301c <open+0x11c>
    }
    else
    {
      fd = &alt_fd_list[index];
 8302f84:	e0fffe17 	ldw	r3,-8(fp)
 8302f88:	1805883a 	mov	r2,r3
 8302f8c:	1085883a 	add	r2,r2,r2
 8302f90:	10c5883a 	add	r2,r2,r3
 8302f94:	100490ba 	slli	r2,r2,2
 8302f98:	00c20c34 	movhi	r3,2096
 8302f9c:	18d2d904 	addi	r3,r3,19300
 8302fa0:	10c5883a 	add	r2,r2,r3
 8302fa4:	e0bffb15 	stw	r2,-20(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 8302fa8:	e0fff917 	ldw	r3,-28(fp)
 8302fac:	00900034 	movhi	r2,16384
 8302fb0:	10bfffc4 	addi	r2,r2,-1
 8302fb4:	1886703a 	and	r3,r3,r2
 8302fb8:	e0bffb17 	ldw	r2,-20(fp)
 8302fbc:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 8302fc0:	e0bffc17 	ldw	r2,-16(fp)
 8302fc4:	1000051e 	bne	r2,zero,8302fdc <open+0xdc>
 8302fc8:	e13ffb17 	ldw	r4,-20(fp)
 8302fcc:	8302e240 	call	8302e24 <alt_file_locked>
 8302fd0:	e0bffd15 	stw	r2,-12(fp)
 8302fd4:	e0bffd17 	ldw	r2,-12(fp)
 8302fd8:	10001016 	blt	r2,zero,830301c <open+0x11c>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 8302fdc:	e0bfff17 	ldw	r2,-4(fp)
 8302fe0:	10800317 	ldw	r2,12(r2)
 8302fe4:	10000826 	beq	r2,zero,8303008 <open+0x108>
 8302fe8:	e0bfff17 	ldw	r2,-4(fp)
 8302fec:	10800317 	ldw	r2,12(r2)
 8302ff0:	e1fff817 	ldw	r7,-32(fp)
 8302ff4:	e1bff917 	ldw	r6,-28(fp)
 8302ff8:	e17ffa17 	ldw	r5,-24(fp)
 8302ffc:	e13ffb17 	ldw	r4,-20(fp)
 8303000:	103ee83a 	callr	r2
 8303004:	00000106 	br	830300c <open+0x10c>
 8303008:	0005883a 	mov	r2,zero
 830300c:	e0bffd15 	stw	r2,-12(fp)
 8303010:	00000206 	br	830301c <open+0x11c>
      }
    }
  }
  else
  {
    status = -ENODEV;
 8303014:	00bffb44 	movi	r2,-19
 8303018:	e0bffd15 	stw	r2,-12(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 830301c:	e0bffd17 	ldw	r2,-12(fp)
 8303020:	1000090e 	bge	r2,zero,8303048 <open+0x148>
  {
    alt_release_fd (index);  
 8303024:	e13ffe17 	ldw	r4,-8(fp)
 8303028:	83030600 	call	8303060 <alt_release_fd>
    ALT_ERRNO = -status;
 830302c:	8302de80 	call	8302de8 <alt_get_errno>
 8303030:	1007883a 	mov	r3,r2
 8303034:	e0bffd17 	ldw	r2,-12(fp)
 8303038:	0085c83a 	sub	r2,zero,r2
 830303c:	18800015 	stw	r2,0(r3)
    return -1;
 8303040:	00bfffc4 	movi	r2,-1
 8303044:	00000106 	br	830304c <open+0x14c>
  }
  
  /* return the reference upon success */

  return index;
 8303048:	e0bffe17 	ldw	r2,-8(fp)
}
 830304c:	e037883a 	mov	sp,fp
 8303050:	dfc00117 	ldw	ra,4(sp)
 8303054:	df000017 	ldw	fp,0(sp)
 8303058:	dec00204 	addi	sp,sp,8
 830305c:	f800283a 	ret

08303060 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 8303060:	defffe04 	addi	sp,sp,-8
 8303064:	df000115 	stw	fp,4(sp)
 8303068:	df000104 	addi	fp,sp,4
 830306c:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 8303070:	e0bfff17 	ldw	r2,-4(fp)
 8303074:	108000d0 	cmplti	r2,r2,3
 8303078:	1000101e 	bne	r2,zero,83030bc <alt_release_fd+0x5c>
  {
    alt_fd_list[fd].fd_flags = 0;
 830307c:	e0ffff17 	ldw	r3,-4(fp)
 8303080:	1805883a 	mov	r2,r3
 8303084:	1085883a 	add	r2,r2,r2
 8303088:	10c5883a 	add	r2,r2,r3
 830308c:	100490ba 	slli	r2,r2,2
 8303090:	00c20c34 	movhi	r3,2096
 8303094:	10c7883a 	add	r3,r2,r3
 8303098:	1812db15 	stw	zero,19308(r3)
    alt_fd_list[fd].dev      = 0;
 830309c:	e0ffff17 	ldw	r3,-4(fp)
 83030a0:	1805883a 	mov	r2,r3
 83030a4:	1085883a 	add	r2,r2,r2
 83030a8:	10c5883a 	add	r2,r2,r3
 83030ac:	100490ba 	slli	r2,r2,2
 83030b0:	00c20c34 	movhi	r3,2096
 83030b4:	10c7883a 	add	r3,r2,r3
 83030b8:	1812d915 	stw	zero,19300(r3)
  }
}
 83030bc:	0001883a 	nop
 83030c0:	e037883a 	mov	sp,fp
 83030c4:	df000017 	ldw	fp,0(sp)
 83030c8:	dec00104 	addi	sp,sp,4
 83030cc:	f800283a 	ret

083030d0 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 83030d0:	defffa04 	addi	sp,sp,-24
 83030d4:	df000515 	stw	fp,20(sp)
 83030d8:	df000504 	addi	fp,sp,20
 83030dc:	e13ffb15 	stw	r4,-20(fp)
  NIOS2_READ_STATUS (context);
 83030e0:	0005303a 	rdctl	r2,status
 83030e4:	e0bffc15 	stw	r2,-16(fp)
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 83030e8:	e0fffc17 	ldw	r3,-16(fp)
 83030ec:	00bfff84 	movi	r2,-2
 83030f0:	1884703a 	and	r2,r3,r2
 83030f4:	1001703a 	wrctl	status,r2
  return context;
 83030f8:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 83030fc:	e0bfff15 	stw	r2,-4(fp)
  alt_llist_remove (&alarm->llist);
 8303100:	e0bffb17 	ldw	r2,-20(fp)
 8303104:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 8303108:	e0bffd17 	ldw	r2,-12(fp)
 830310c:	10800017 	ldw	r2,0(r2)
 8303110:	e0fffd17 	ldw	r3,-12(fp)
 8303114:	18c00117 	ldw	r3,4(r3)
 8303118:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 830311c:	e0bffd17 	ldw	r2,-12(fp)
 8303120:	10800117 	ldw	r2,4(r2)
 8303124:	e0fffd17 	ldw	r3,-12(fp)
 8303128:	18c00017 	ldw	r3,0(r3)
 830312c:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 8303130:	e0bffd17 	ldw	r2,-12(fp)
 8303134:	e0fffd17 	ldw	r3,-12(fp)
 8303138:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 830313c:	e0bffd17 	ldw	r2,-12(fp)
 8303140:	e0fffd17 	ldw	r3,-12(fp)
 8303144:	10c00015 	stw	r3,0(r2)
} 
 8303148:	0001883a 	nop
 830314c:	e0bfff17 	ldw	r2,-4(fp)
 8303150:	e0bffe15 	stw	r2,-8(fp)
  NIOS2_WRITE_STATUS (context);
 8303154:	e0bffe17 	ldw	r2,-8(fp)
 8303158:	1001703a 	wrctl	status,r2
}
 830315c:	0001883a 	nop
  alt_irq_enable_all (irq_context);
}
 8303160:	0001883a 	nop
 8303164:	e037883a 	mov	sp,fp
 8303168:	df000017 	ldw	fp,0(sp)
 830316c:	dec00104 	addi	sp,sp,4
 8303170:	f800283a 	ret

08303174 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 8303174:	defffb04 	addi	sp,sp,-20
 8303178:	dfc00415 	stw	ra,16(sp)
 830317c:	df000315 	stw	fp,12(sp)
 8303180:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 8303184:	d0a00917 	ldw	r2,-32732(gp)
 8303188:	e0bfff15 	stw	r2,-4(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 830318c:	d0a5ea17 	ldw	r2,-26712(gp)
 8303190:	10800044 	addi	r2,r2,1
 8303194:	d0a5ea15 	stw	r2,-26712(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 8303198:	00002e06 	br	8303254 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 830319c:	e0bfff17 	ldw	r2,-4(fp)
 83031a0:	10800017 	ldw	r2,0(r2)
 83031a4:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 83031a8:	e0bfff17 	ldw	r2,-4(fp)
 83031ac:	10800403 	ldbu	r2,16(r2)
 83031b0:	10803fcc 	andi	r2,r2,255
 83031b4:	10000426 	beq	r2,zero,83031c8 <alt_tick+0x54>
 83031b8:	d0a5ea17 	ldw	r2,-26712(gp)
 83031bc:	1000021e 	bne	r2,zero,83031c8 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 83031c0:	e0bfff17 	ldw	r2,-4(fp)
 83031c4:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 83031c8:	e0bfff17 	ldw	r2,-4(fp)
 83031cc:	10800217 	ldw	r2,8(r2)
 83031d0:	d0e5ea17 	ldw	r3,-26712(gp)
 83031d4:	18801d36 	bltu	r3,r2,830324c <alt_tick+0xd8>
 83031d8:	e0bfff17 	ldw	r2,-4(fp)
 83031dc:	10800403 	ldbu	r2,16(r2)
 83031e0:	10803fcc 	andi	r2,r2,255
 83031e4:	1000191e 	bne	r2,zero,830324c <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 83031e8:	e0bfff17 	ldw	r2,-4(fp)
 83031ec:	10800317 	ldw	r2,12(r2)
 83031f0:	e0ffff17 	ldw	r3,-4(fp)
 83031f4:	18c00517 	ldw	r3,20(r3)
 83031f8:	1809883a 	mov	r4,r3
 83031fc:	103ee83a 	callr	r2
 8303200:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 8303204:	e0bffd17 	ldw	r2,-12(fp)
 8303208:	1000031e 	bne	r2,zero,8303218 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 830320c:	e13fff17 	ldw	r4,-4(fp)
 8303210:	83030d00 	call	83030d0 <alt_alarm_stop>
 8303214:	00000d06 	br	830324c <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 8303218:	e0bfff17 	ldw	r2,-4(fp)
 830321c:	10c00217 	ldw	r3,8(r2)
 8303220:	e0bffd17 	ldw	r2,-12(fp)
 8303224:	1887883a 	add	r3,r3,r2
 8303228:	e0bfff17 	ldw	r2,-4(fp)
 830322c:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 8303230:	e0bfff17 	ldw	r2,-4(fp)
 8303234:	10c00217 	ldw	r3,8(r2)
 8303238:	d0a5ea17 	ldw	r2,-26712(gp)
 830323c:	1880032e 	bgeu	r3,r2,830324c <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 8303240:	e0bfff17 	ldw	r2,-4(fp)
 8303244:	00c00044 	movi	r3,1
 8303248:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 830324c:	e0bffe17 	ldw	r2,-8(fp)
 8303250:	e0bfff15 	stw	r2,-4(fp)
  while (alarm != (alt_alarm*) &alt_alarm_list)
 8303254:	e0ffff17 	ldw	r3,-4(fp)
 8303258:	d0a00904 	addi	r2,gp,-32732
 830325c:	18bfcf1e 	bne	r3,r2,830319c <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 8303260:	0001883a 	nop
}
 8303264:	0001883a 	nop
 8303268:	e037883a 	mov	sp,fp
 830326c:	dfc00117 	ldw	ra,4(sp)
 8303270:	df000017 	ldw	fp,0(sp)
 8303274:	dec00204 	addi	sp,sp,8
 8303278:	f800283a 	ret

0830327c <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 830327c:	deffff04 	addi	sp,sp,-4
 8303280:	df000015 	stw	fp,0(sp)
 8303284:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 8303288:	000170fa 	wrctl	ienable,zero
}
 830328c:	0001883a 	nop
 8303290:	e037883a 	mov	sp,fp
 8303294:	df000017 	ldw	fp,0(sp)
 8303298:	dec00104 	addi	sp,sp,4
 830329c:	f800283a 	ret

083032a0 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 83032a0:	defffb04 	addi	sp,sp,-20
 83032a4:	dfc00415 	stw	ra,16(sp)
 83032a8:	df000315 	stw	fp,12(sp)
 83032ac:	df000304 	addi	fp,sp,12
 83032b0:	e13ffd15 	stw	r4,-12(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 83032b4:	d0a00317 	ldw	r2,-32756(gp)
 83032b8:	e0bfff15 	stw	r2,-4(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 83032bc:	00003106 	br	8303384 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 83032c0:	e0bfff17 	ldw	r2,-4(fp)
 83032c4:	10800217 	ldw	r2,8(r2)
 83032c8:	1009883a 	mov	r4,r2
 83032cc:	83036b80 	call	83036b8 <strlen>
 83032d0:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 83032d4:	e0bfff17 	ldw	r2,-4(fp)
 83032d8:	10c00217 	ldw	r3,8(r2)
 83032dc:	e0bffe17 	ldw	r2,-8(fp)
 83032e0:	10bfffc4 	addi	r2,r2,-1
 83032e4:	1885883a 	add	r2,r3,r2
 83032e8:	10800003 	ldbu	r2,0(r2)
 83032ec:	10803fcc 	andi	r2,r2,255
 83032f0:	1080201c 	xori	r2,r2,128
 83032f4:	10bfe004 	addi	r2,r2,-128
 83032f8:	10800bd8 	cmpnei	r2,r2,47
 83032fc:	1000031e 	bne	r2,zero,830330c <alt_find_file+0x6c>
    {
      len -= 1;
 8303300:	e0bffe17 	ldw	r2,-8(fp)
 8303304:	10bfffc4 	addi	r2,r2,-1
 8303308:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 830330c:	e0bffe17 	ldw	r2,-8(fp)
 8303310:	e0fffd17 	ldw	r3,-12(fp)
 8303314:	1885883a 	add	r2,r3,r2
 8303318:	10800003 	ldbu	r2,0(r2)
 830331c:	10803fcc 	andi	r2,r2,255
 8303320:	1080201c 	xori	r2,r2,128
 8303324:	10bfe004 	addi	r2,r2,-128
 8303328:	10800be0 	cmpeqi	r2,r2,47
 830332c:	1000081e 	bne	r2,zero,8303350 <alt_find_file+0xb0>
 8303330:	e0bffe17 	ldw	r2,-8(fp)
 8303334:	e0fffd17 	ldw	r3,-12(fp)
 8303338:	1885883a 	add	r2,r3,r2
 830333c:	10800003 	ldbu	r2,0(r2)
 8303340:	10803fcc 	andi	r2,r2,255
 8303344:	1080201c 	xori	r2,r2,128
 8303348:	10bfe004 	addi	r2,r2,-128
 830334c:	10000a1e 	bne	r2,zero,8303378 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 8303350:	e0bfff17 	ldw	r2,-4(fp)
 8303354:	10800217 	ldw	r2,8(r2)
 8303358:	e0fffe17 	ldw	r3,-8(fp)
 830335c:	180d883a 	mov	r6,r3
 8303360:	e17ffd17 	ldw	r5,-12(fp)
 8303364:	1009883a 	mov	r4,r2
 8303368:	83035400 	call	8303540 <memcmp>
    if (((name[len] == '/') || (name[len] == '\0')) && 
 830336c:	1000021e 	bne	r2,zero,8303378 <alt_find_file+0xd8>
    {
      /* match found */

      return next;
 8303370:	e0bfff17 	ldw	r2,-4(fp)
 8303374:	00000706 	br	8303394 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 8303378:	e0bfff17 	ldw	r2,-4(fp)
 830337c:	10800017 	ldw	r2,0(r2)
 8303380:	e0bfff15 	stw	r2,-4(fp)
  while (next != (alt_dev*) &alt_fs_list)
 8303384:	e0ffff17 	ldw	r3,-4(fp)
 8303388:	d0a00304 	addi	r2,gp,-32756
 830338c:	18bfcc1e 	bne	r3,r2,83032c0 <alt_find_file+0x20>
  }
  
  /* No match found */
  
  return NULL;     
 8303390:	0005883a 	mov	r2,zero
}
 8303394:	e037883a 	mov	sp,fp
 8303398:	dfc00117 	ldw	ra,4(sp)
 830339c:	df000017 	ldw	fp,0(sp)
 83033a0:	dec00204 	addi	sp,sp,8
 83033a4:	f800283a 	ret

083033a8 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 83033a8:	defffc04 	addi	sp,sp,-16
 83033ac:	df000315 	stw	fp,12(sp)
 83033b0:	df000304 	addi	fp,sp,12
 83033b4:	e13ffd15 	stw	r4,-12(fp)
  alt_32 i;
  int rc = -EMFILE;
 83033b8:	00bffa04 	movi	r2,-24
 83033bc:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 83033c0:	e03fff15 	stw	zero,-4(fp)
 83033c4:	00001d06 	br	830343c <alt_get_fd+0x94>
  {
    if (!alt_fd_list[i].dev)
 83033c8:	e0ffff17 	ldw	r3,-4(fp)
 83033cc:	1805883a 	mov	r2,r3
 83033d0:	1085883a 	add	r2,r2,r2
 83033d4:	10c5883a 	add	r2,r2,r3
 83033d8:	100490ba 	slli	r2,r2,2
 83033dc:	00c20c34 	movhi	r3,2096
 83033e0:	10c7883a 	add	r3,r2,r3
 83033e4:	1892d917 	ldw	r2,19300(r3)
 83033e8:	1000111e 	bne	r2,zero,8303430 <alt_get_fd+0x88>
    {
      alt_fd_list[i].dev = dev;
 83033ec:	e0ffff17 	ldw	r3,-4(fp)
 83033f0:	1805883a 	mov	r2,r3
 83033f4:	1085883a 	add	r2,r2,r2
 83033f8:	10c5883a 	add	r2,r2,r3
 83033fc:	100490ba 	slli	r2,r2,2
 8303400:	e13ffd17 	ldw	r4,-12(fp)
 8303404:	00c20c34 	movhi	r3,2096
 8303408:	10c7883a 	add	r3,r2,r3
 830340c:	1912d915 	stw	r4,19300(r3)
      if (i > alt_max_fd)
 8303410:	d0e00717 	ldw	r3,-32740(gp)
 8303414:	e0bfff17 	ldw	r2,-4(fp)
 8303418:	1880020e 	bge	r3,r2,8303424 <alt_get_fd+0x7c>
      {
        alt_max_fd = i;
 830341c:	e0bfff17 	ldw	r2,-4(fp)
 8303420:	d0a00715 	stw	r2,-32740(gp)
      }
      rc = i;
 8303424:	e0bfff17 	ldw	r2,-4(fp)
 8303428:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
 830342c:	00000706 	br	830344c <alt_get_fd+0xa4>
  for (i = 0; i < ALT_MAX_FD; i++)
 8303430:	e0bfff17 	ldw	r2,-4(fp)
 8303434:	10800044 	addi	r2,r2,1
 8303438:	e0bfff15 	stw	r2,-4(fp)
 830343c:	e0bfff17 	ldw	r2,-4(fp)
 8303440:	10800810 	cmplti	r2,r2,32
 8303444:	103fe01e 	bne	r2,zero,83033c8 <alt_get_fd+0x20>
    }
  }

 alt_get_fd_exit:
 8303448:	0001883a 	nop
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 830344c:	e0bffe17 	ldw	r2,-8(fp)
}
 8303450:	e037883a 	mov	sp,fp
 8303454:	df000017 	ldw	fp,0(sp)
 8303458:	dec00104 	addi	sp,sp,4
 830345c:	f800283a 	ret

08303460 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
 8303460:	defffe04 	addi	sp,sp,-8
 8303464:	df000115 	stw	fp,4(sp)
 8303468:	df000104 	addi	fp,sp,4
 830346c:	e13fff15 	stw	r4,-4(fp)
 8303470:	e0bfff17 	ldw	r2,-4(fp)
 8303474:	10bffe84 	addi	r2,r2,-6
 8303478:	10c00428 	cmpgeui	r3,r2,16
 830347c:	1800191e 	bne	r3,zero,83034e4 <alt_exception_cause_generated_bad_addr+0x84>
 8303480:	100690ba 	slli	r3,r2,2
 8303484:	00820c34 	movhi	r2,2096
 8303488:	1885883a 	add	r2,r3,r2
 830348c:	108d2517 	ldw	r2,13460(r2)
 8303490:	1000683a 	jmp	r2
 8303494:	083034d4 	ori	zero,at,49363
 8303498:	083034d4 	ori	zero,at,49363
 830349c:	083034e4 	muli	zero,at,-16173
 83034a0:	083034e4 	muli	zero,at,-16173
 83034a4:	083034e4 	muli	zero,at,-16173
 83034a8:	083034d4 	ori	zero,at,49363
 83034ac:	083034dc 	xori	zero,at,49363
 83034b0:	083034e4 	muli	zero,at,-16173
 83034b4:	083034d4 	ori	zero,at,49363
 83034b8:	083034d4 	ori	zero,at,49363
 83034bc:	083034e4 	muli	zero,at,-16173
 83034c0:	083034d4 	ori	zero,at,49363
 83034c4:	083034dc 	xori	zero,at,49363
 83034c8:	083034e4 	muli	zero,at,-16173
 83034cc:	083034e4 	muli	zero,at,-16173
 83034d0:	083034d4 	ori	zero,at,49363
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
 83034d4:	00800044 	movi	r2,1
 83034d8:	00000306 	br	83034e8 <alt_exception_cause_generated_bad_addr+0x88>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
 83034dc:	0005883a 	mov	r2,zero
 83034e0:	00000106 	br	83034e8 <alt_exception_cause_generated_bad_addr+0x88>

  default:
    return 0;
 83034e4:	0005883a 	mov	r2,zero
  }
}
 83034e8:	e037883a 	mov	sp,fp
 83034ec:	df000017 	ldw	fp,0(sp)
 83034f0:	dec00104 	addi	sp,sp,4
 83034f4:	f800283a 	ret

083034f8 <atexit>:
 83034f8:	200b883a 	mov	r5,r4
 83034fc:	000f883a 	mov	r7,zero
 8303500:	000d883a 	mov	r6,zero
 8303504:	0009883a 	mov	r4,zero
 8303508:	83037501 	jmpi	8303750 <__register_exitproc>

0830350c <exit>:
 830350c:	defffe04 	addi	sp,sp,-8
 8303510:	000b883a 	mov	r5,zero
 8303514:	dc000015 	stw	r16,0(sp)
 8303518:	dfc00115 	stw	ra,4(sp)
 830351c:	2021883a 	mov	r16,r4
 8303520:	83037e00 	call	83037e0 <__call_exitprocs>
 8303524:	00820c34 	movhi	r2,2096
 8303528:	11144d17 	ldw	r4,20788(r2)
 830352c:	20800f17 	ldw	r2,60(r4)
 8303530:	10000126 	beq	r2,zero,8303538 <exit+0x2c>
 8303534:	103ee83a 	callr	r2
 8303538:	8009883a 	mov	r4,r16
 830353c:	83039000 	call	8303900 <_exit>

08303540 <memcmp>:
 8303540:	30800130 	cmpltui	r2,r6,4
 8303544:	10000b1e 	bne	r2,zero,8303574 <memcmp+0x34>
 8303548:	2144b03a 	or	r2,r4,r5
 830354c:	108000cc 	andi	r2,r2,3
 8303550:	1000171e 	bne	r2,zero,83035b0 <memcmp+0x70>
 8303554:	20c00017 	ldw	r3,0(r4)
 8303558:	28800017 	ldw	r2,0(r5)
 830355c:	1880141e 	bne	r3,r2,83035b0 <memcmp+0x70>
 8303560:	31bfff04 	addi	r6,r6,-4
 8303564:	30800128 	cmpgeui	r2,r6,4
 8303568:	21000104 	addi	r4,r4,4
 830356c:	29400104 	addi	r5,r5,4
 8303570:	103ff81e 	bne	r2,zero,8303554 <memcmp+0x14>
 8303574:	30bfffc4 	addi	r2,r6,-1
 8303578:	30000b26 	beq	r6,zero,83035a8 <memcmp+0x68>
 830357c:	11800044 	addi	r6,r2,1
 8303580:	298d883a 	add	r6,r5,r6
 8303584:	00000106 	br	830358c <memcmp+0x4c>
 8303588:	29800726 	beq	r5,r6,83035a8 <memcmp+0x68>
 830358c:	20800003 	ldbu	r2,0(r4)
 8303590:	28c00003 	ldbu	r3,0(r5)
 8303594:	21000044 	addi	r4,r4,1
 8303598:	29400044 	addi	r5,r5,1
 830359c:	10fffa26 	beq	r2,r3,8303588 <memcmp+0x48>
 83035a0:	10c5c83a 	sub	r2,r2,r3
 83035a4:	f800283a 	ret
 83035a8:	0005883a 	mov	r2,zero
 83035ac:	f800283a 	ret
 83035b0:	30bfffc4 	addi	r2,r6,-1
 83035b4:	003ff106 	br	830357c <memcmp+0x3c>

083035b8 <memcpy>:
 83035b8:	30c00430 	cmpltui	r3,r6,16
 83035bc:	2005883a 	mov	r2,r4
 83035c0:	18002d1e 	bne	r3,zero,8303678 <memcpy+0xc0>
 83035c4:	2906b03a 	or	r3,r5,r4
 83035c8:	18c000cc 	andi	r3,r3,3
 83035cc:	1800351e 	bne	r3,zero,83036a4 <memcpy+0xec>
 83035d0:	32fffc04 	addi	r11,r6,-16
 83035d4:	5816d13a 	srli	r11,r11,4
 83035d8:	280f883a 	mov	r7,r5
 83035dc:	2007883a 	mov	r3,r4
 83035e0:	5ac00044 	addi	r11,r11,1
 83035e4:	5816913a 	slli	r11,r11,4
 83035e8:	22d5883a 	add	r10,r4,r11
 83035ec:	39000117 	ldw	r4,4(r7)
 83035f0:	3a400017 	ldw	r9,0(r7)
 83035f4:	3a000217 	ldw	r8,8(r7)
 83035f8:	19000115 	stw	r4,4(r3)
 83035fc:	39000317 	ldw	r4,12(r7)
 8303600:	1a400015 	stw	r9,0(r3)
 8303604:	1a000215 	stw	r8,8(r3)
 8303608:	19000315 	stw	r4,12(r3)
 830360c:	18c00404 	addi	r3,r3,16
 8303610:	39c00404 	addi	r7,r7,16
 8303614:	50fff51e 	bne	r10,r3,83035ec <memcpy+0x34>
 8303618:	3100030c 	andi	r4,r6,12
 830361c:	2acb883a 	add	r5,r5,r11
 8303620:	320003cc 	andi	r8,r6,15
 8303624:	20002226 	beq	r4,zero,83036b0 <memcpy+0xf8>
 8303628:	280f883a 	mov	r7,r5
 830362c:	1813883a 	mov	r9,r3
 8303630:	39c00104 	addi	r7,r7,4
 8303634:	3abfff17 	ldw	r10,-4(r7)
 8303638:	41c9c83a 	sub	r4,r8,r7
 830363c:	2909883a 	add	r4,r5,r4
 8303640:	4a800015 	stw	r10,0(r9)
 8303644:	21000128 	cmpgeui	r4,r4,4
 8303648:	4a400104 	addi	r9,r9,4
 830364c:	203ff81e 	bne	r4,zero,8303630 <memcpy+0x78>
 8303650:	413fff04 	addi	r4,r8,-4
 8303654:	2008d0ba 	srli	r4,r4,2
 8303658:	318000cc 	andi	r6,r6,3
 830365c:	31ffffc4 	addi	r7,r6,-1
 8303660:	21000044 	addi	r4,r4,1
 8303664:	200890ba 	slli	r4,r4,2
 8303668:	1907883a 	add	r3,r3,r4
 830366c:	290b883a 	add	r5,r5,r4
 8303670:	3000041e 	bne	r6,zero,8303684 <memcpy+0xcc>
 8303674:	f800283a 	ret
 8303678:	2007883a 	mov	r3,r4
 830367c:	31ffffc4 	addi	r7,r6,-1
 8303680:	303ffc26 	beq	r6,zero,8303674 <memcpy+0xbc>
 8303684:	39c00044 	addi	r7,r7,1
 8303688:	19cf883a 	add	r7,r3,r7
 830368c:	29800003 	ldbu	r6,0(r5)
 8303690:	18c00044 	addi	r3,r3,1
 8303694:	29400044 	addi	r5,r5,1
 8303698:	19bfffc5 	stb	r6,-1(r3)
 830369c:	38fffb1e 	bne	r7,r3,830368c <memcpy+0xd4>
 83036a0:	f800283a 	ret
 83036a4:	31ffffc4 	addi	r7,r6,-1
 83036a8:	2007883a 	mov	r3,r4
 83036ac:	003ff506 	br	8303684 <memcpy+0xcc>
 83036b0:	400d883a 	mov	r6,r8
 83036b4:	003ff106 	br	830367c <memcpy+0xc4>

083036b8 <strlen>:
 83036b8:	208000cc 	andi	r2,r4,3
 83036bc:	10000926 	beq	r2,zero,83036e4 <strlen+0x2c>
 83036c0:	2005883a 	mov	r2,r4
 83036c4:	00000306 	br	83036d4 <strlen+0x1c>
 83036c8:	10800044 	addi	r2,r2,1
 83036cc:	10c000cc 	andi	r3,r2,3
 83036d0:	18000526 	beq	r3,zero,83036e8 <strlen+0x30>
 83036d4:	10c00007 	ldb	r3,0(r2)
 83036d8:	183ffb1e 	bne	r3,zero,83036c8 <strlen+0x10>
 83036dc:	1105c83a 	sub	r2,r2,r4
 83036e0:	f800283a 	ret
 83036e4:	2005883a 	mov	r2,r4
 83036e8:	11400017 	ldw	r5,0(r2)
 83036ec:	01ffbff4 	movhi	r7,65279
 83036f0:	39ffbfc4 	addi	r7,r7,-257
 83036f4:	29c7883a 	add	r3,r5,r7
 83036f8:	01a02074 	movhi	r6,32897
 83036fc:	014a303a 	nor	r5,zero,r5
 8303700:	1946703a 	and	r3,r3,r5
 8303704:	31a02004 	addi	r6,r6,-32640
 8303708:	1986703a 	and	r3,r3,r6
 830370c:	1800071e 	bne	r3,zero,830372c <strlen+0x74>
 8303710:	11400117 	ldw	r5,4(r2)
 8303714:	10800104 	addi	r2,r2,4
 8303718:	29c7883a 	add	r3,r5,r7
 830371c:	014a303a 	nor	r5,zero,r5
 8303720:	1946703a 	and	r3,r3,r5
 8303724:	1986703a 	and	r3,r3,r6
 8303728:	183ff926 	beq	r3,zero,8303710 <strlen+0x58>
 830372c:	10c00007 	ldb	r3,0(r2)
 8303730:	183fea26 	beq	r3,zero,83036dc <strlen+0x24>
 8303734:	10c00047 	ldb	r3,1(r2)
 8303738:	10800044 	addi	r2,r2,1
 830373c:	183fe726 	beq	r3,zero,83036dc <strlen+0x24>
 8303740:	10c00047 	ldb	r3,1(r2)
 8303744:	10800044 	addi	r2,r2,1
 8303748:	183ffa1e 	bne	r3,zero,8303734 <strlen+0x7c>
 830374c:	003fe306 	br	83036dc <strlen+0x24>

08303750 <__register_exitproc>:
 8303750:	00820c34 	movhi	r2,2096
 8303754:	10d44d17 	ldw	r3,20788(r2)
 8303758:	18805217 	ldw	r2,328(r3)
 830375c:	10001726 	beq	r2,zero,83037bc <__register_exitproc+0x6c>
 8303760:	10c00117 	ldw	r3,4(r2)
 8303764:	1a000808 	cmpgei	r8,r3,32
 8303768:	40001b1e 	bne	r8,zero,83037d8 <__register_exitproc+0x88>
 830376c:	20000b26 	beq	r4,zero,830379c <__register_exitproc+0x4c>
 8303770:	181090ba 	slli	r8,r3,2
 8303774:	02400044 	movi	r9,1
 8303778:	48d2983a 	sll	r9,r9,r3
 830377c:	1211883a 	add	r8,r2,r8
 8303780:	41802215 	stw	r6,136(r8)
 8303784:	11806217 	ldw	r6,392(r2)
 8303788:	21000098 	cmpnei	r4,r4,2
 830378c:	324cb03a 	or	r6,r6,r9
 8303790:	11806215 	stw	r6,392(r2)
 8303794:	41c04215 	stw	r7,264(r8)
 8303798:	20000b26 	beq	r4,zero,83037c8 <__register_exitproc+0x78>
 830379c:	19000084 	addi	r4,r3,2
 83037a0:	200890ba 	slli	r4,r4,2
 83037a4:	18c00044 	addi	r3,r3,1
 83037a8:	10c00115 	stw	r3,4(r2)
 83037ac:	1105883a 	add	r2,r2,r4
 83037b0:	11400015 	stw	r5,0(r2)
 83037b4:	0005883a 	mov	r2,zero
 83037b8:	f800283a 	ret
 83037bc:	18805304 	addi	r2,r3,332
 83037c0:	18805215 	stw	r2,328(r3)
 83037c4:	003fe606 	br	8303760 <__register_exitproc+0x10>
 83037c8:	11006317 	ldw	r4,396(r2)
 83037cc:	2252b03a 	or	r9,r4,r9
 83037d0:	12406315 	stw	r9,396(r2)
 83037d4:	003ff106 	br	830379c <__register_exitproc+0x4c>
 83037d8:	00bfffc4 	movi	r2,-1
 83037dc:	f800283a 	ret

083037e0 <__call_exitprocs>:
 83037e0:	defff704 	addi	sp,sp,-36
 83037e4:	00820c34 	movhi	r2,2096
 83037e8:	dcc00315 	stw	r19,12(sp)
 83037ec:	14d44d17 	ldw	r19,20788(r2)
 83037f0:	dc800215 	stw	r18,8(sp)
 83037f4:	dfc00815 	stw	ra,32(sp)
 83037f8:	9c805217 	ldw	r18,328(r19)
 83037fc:	ddc00715 	stw	r23,28(sp)
 8303800:	dd800615 	stw	r22,24(sp)
 8303804:	dd400515 	stw	r21,20(sp)
 8303808:	dd000415 	stw	r20,16(sp)
 830380c:	dc400115 	stw	r17,4(sp)
 8303810:	dc000015 	stw	r16,0(sp)
 8303814:	90001026 	beq	r18,zero,8303858 <__call_exitprocs+0x78>
 8303818:	202b883a 	mov	r21,r4
 830381c:	282d883a 	mov	r22,r5
 8303820:	05000044 	movi	r20,1
 8303824:	94000117 	ldw	r16,4(r18)
 8303828:	847fffc4 	addi	r17,r16,-1
 830382c:	88000a16 	blt	r17,zero,8303858 <__call_exitprocs+0x78>
 8303830:	84000044 	addi	r16,r16,1
 8303834:	802090ba 	slli	r16,r16,2
 8303838:	9421883a 	add	r16,r18,r16
 830383c:	b0001126 	beq	r22,zero,8303884 <__call_exitprocs+0xa4>
 8303840:	80804017 	ldw	r2,256(r16)
 8303844:	15800f26 	beq	r2,r22,8303884 <__call_exitprocs+0xa4>
 8303848:	8c7fffc4 	addi	r17,r17,-1
 830384c:	88bfffd8 	cmpnei	r2,r17,-1
 8303850:	843fff04 	addi	r16,r16,-4
 8303854:	103ff91e 	bne	r2,zero,830383c <__call_exitprocs+0x5c>
 8303858:	dfc00817 	ldw	ra,32(sp)
 830385c:	ddc00717 	ldw	r23,28(sp)
 8303860:	dd800617 	ldw	r22,24(sp)
 8303864:	dd400517 	ldw	r21,20(sp)
 8303868:	dd000417 	ldw	r20,16(sp)
 830386c:	dcc00317 	ldw	r19,12(sp)
 8303870:	dc800217 	ldw	r18,8(sp)
 8303874:	dc400117 	ldw	r17,4(sp)
 8303878:	dc000017 	ldw	r16,0(sp)
 830387c:	dec00904 	addi	sp,sp,36
 8303880:	f800283a 	ret
 8303884:	90800117 	ldw	r2,4(r18)
 8303888:	81800017 	ldw	r6,0(r16)
 830388c:	10bfffc4 	addi	r2,r2,-1
 8303890:	14401726 	beq	r2,r17,83038f0 <__call_exitprocs+0x110>
 8303894:	80000015 	stw	zero,0(r16)
 8303898:	303feb26 	beq	r6,zero,8303848 <__call_exitprocs+0x68>
 830389c:	a446983a 	sll	r3,r20,r17
 83038a0:	90806217 	ldw	r2,392(r18)
 83038a4:	95c00117 	ldw	r23,4(r18)
 83038a8:	1884703a 	and	r2,r3,r2
 83038ac:	1000081e 	bne	r2,zero,83038d0 <__call_exitprocs+0xf0>
 83038b0:	303ee83a 	callr	r6
 83038b4:	90c00117 	ldw	r3,4(r18)
 83038b8:	98805217 	ldw	r2,328(r19)
 83038bc:	1dc0011e 	bne	r3,r23,83038c4 <__call_exitprocs+0xe4>
 83038c0:	90bfe126 	beq	r18,r2,8303848 <__call_exitprocs+0x68>
 83038c4:	103fe426 	beq	r2,zero,8303858 <__call_exitprocs+0x78>
 83038c8:	1025883a 	mov	r18,r2
 83038cc:	003fd506 	br	8303824 <__call_exitprocs+0x44>
 83038d0:	90806317 	ldw	r2,396(r18)
 83038d4:	81002017 	ldw	r4,128(r16)
 83038d8:	1886703a 	and	r3,r3,r2
 83038dc:	1800061e 	bne	r3,zero,83038f8 <__call_exitprocs+0x118>
 83038e0:	200b883a 	mov	r5,r4
 83038e4:	a809883a 	mov	r4,r21
 83038e8:	303ee83a 	callr	r6
 83038ec:	003ff106 	br	83038b4 <__call_exitprocs+0xd4>
 83038f0:	94400115 	stw	r17,4(r18)
 83038f4:	003fe806 	br	8303898 <__call_exitprocs+0xb8>
 83038f8:	303ee83a 	callr	r6
 83038fc:	003fed06 	br	83038b4 <__call_exitprocs+0xd4>

08303900 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 8303900:	defffd04 	addi	sp,sp,-12
 8303904:	df000215 	stw	fp,8(sp)
 8303908:	df000204 	addi	fp,sp,8
 830390c:	e13ffe15 	stw	r4,-8(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 8303910:	0001883a 	nop
 8303914:	e0bffe17 	ldw	r2,-8(fp)
 8303918:	e0bfff15 	stw	r2,-4(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 830391c:	e0bfff17 	ldw	r2,-4(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 8303920:	10000226 	beq	r2,zero,830392c <_exit+0x2c>
    ALT_SIM_FAIL();
 8303924:	002af070 	cmpltui	zero,zero,43969
  } else {
    ALT_SIM_PASS();
  }
#endif /* DEBUG_STUB */
}
 8303928:	00000106 	br	8303930 <_exit+0x30>
    ALT_SIM_PASS();
 830392c:	002af0b0 	cmpltui	zero,zero,43970
}
 8303930:	0001883a 	nop
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 8303934:	003fff06 	br	8303934 <_exit+0x34>
